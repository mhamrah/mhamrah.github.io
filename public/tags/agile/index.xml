<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> </title>
    <link>http://blog.michaelhamrah.com/tags/agile/</link>
    <language>en-us</language>
    <author>Michael Hamrah</author>
    <rights>(C) 2015</rights>
    <updated>2012-01-15 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>Agile: It’s a War on Dates</title>
          <link>http://blog.michaelhamrah.com/2012/01/agile-its-a-war-on-dates/</link>
          <pubDate>Sun, 15 Jan 2012 00:00:00 UTC</pubDate>
          <author>Michael Hamrah</author>
          <guid>http://blog.michaelhamrah.com/2012/01/agile-its-a-war-on-dates/</guid>
          <description>

&lt;p&gt;In a comment to my earlier article &lt;a href=&#34;http://wp.me/pnRto-a1&#34;&gt;Thoughts on Kanban&lt;/a&gt; someone brought up the subject of end dates. Businesses obsess about the &amp;#8220;When can we have it?&amp;#8221; question. Dates and deadlines trump all. Let me tell you a secret: dates are bullshit. It is a prohibitive mentality in today&amp;#8217;s world. Technology needs to reframe the question. Stakeholders need to change their engagement. No company ever succeeded because they made dates. Companies succeed when they continuously deliver innovation. It is not about the destination. It is about the journey and where you end up.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For agile to truly succeed the DNA of the company&amp;#8211;top to bottom&amp;#8211;must be continuous improvement through continuous delivery.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;i-want-everything-now:1219c6c1689c6c74fe0a969441c812fa&#34;&gt;I Want Everything. Now.&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;A friend told me a story of a prioritization meeting he had with a stakeholder. After fleshing out seven distinct features with the dev team, the stakeholder was asked to prioritize. He walked up to the board, put a &amp;#8220;1&amp;#8221; next to everything, and walked out.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Really? Everything is a top priority? So you are saying you would rather have nothing than anything? Then what you want is worthless. You may think you need everything but you are showing your unwillingness to change or improve. People that cannot work through small changes definitely cannot deal with large ones.&lt;/p&gt;

&lt;p&gt;Yes, long-term vision is important. It is the goal. It ensures that everyone heads in the right direction every step of the way. It helps people make reasonable decisions. But it is still long-term; it is just a vision of the future negating the small details that allow the day-to-day. It is painful, ridiculous and unnecessary to wait for the future to just &amp;#8220;appear&amp;#8221;.&lt;/p&gt;

&lt;p&gt;Long term deliverables create impatient, anxious users. It creates large, unmanageable codebases, complex releases, excessive bugs. It disconnects original vision from delivered functionality. The cherry on the cake: it creates a confused user base making awkward and painful adjustments to radical new processes. There is no long-term goal that cannot be broken down and reached via small iterative releases. Baby steps. One at a time, together. It is a three-legged race for everyone.&lt;/p&gt;

&lt;h2 id=&#34;the-devil-is-in-the-details:1219c6c1689c6c74fe0a969441c812fa&#34;&gt;The Devil Is In The Details.&lt;/h2&gt;

&lt;p&gt;This is the root cause of scope creep. &lt;em&gt;Okay, we&amp;#8217;re working on feature x, but can we do this? Can we do this? What about this?&lt;/em&gt; You tell me. Is it more important for you to do that or get what we have out? It is your call! When you look at the backlog is it more important to enhance the current feature or move to the next thing on the list?&lt;/p&gt;

&lt;p&gt;We have daily scrums to answer the improve or move question. Get involved in the day-to-day. Transparency is king. If you don&amp;#8217;t trust the person making the call then don&amp;#8217;t let them make the call. Empower key people: it&amp;#8217;s an organizational change which pushes agile forward.&lt;/p&gt;

&lt;p&gt;Active engagement between stakeholders and developers is agile development. The less barriers between the two the better. Getting a common sub-conscience understanding of &amp;#8220;what we are doing&amp;#8221; is the key to success. Small companies align on vision easily. Large companies need to break up into teams and align on goals.&lt;/p&gt;

&lt;h2 id=&#34;deadlines-get-things-done:1219c6c1689c6c74fe0a969441c812fa&#34;&gt;Deadlines Get Things Done&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;You want to know if this really complex thing you are asking for can be done in eight weeks? Can you spell out every possible detail, define every wireframe, tell me how it should look on every device to every user in the world, outline every workflow, specify the amount of load it requires, explain how you will want to enhance it in the future, not bother us at all while we build it, let us decide any confusing or ambiguous detail, then maybe, maybe, I can do this thing that nobody has ever done before in eight weeks. If eight weeks later when you are unhappy with that one thing you did not explicitly specify (even though I totally asked you to specify everything) I will tell you &amp;#8220;It wasn&amp;#8217;t in the reqs&amp;#8221;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Is that how you want to work? Or would you rather tell me the gist of what we are doing, come up with a plan to get there, see what we can do first quickly, get it out, then take it from there. Is outlining every validation error on every page necessary to do now or can we start with the first page and take it from there?&lt;/p&gt;

&lt;p&gt;You may also use deadlines to motivate people. Vision, direction and importance also motivate people. It is pretty easy to get something done by saying &amp;#8220;This needs to happen by this date&amp;#8221;. But that shows you do not care what it does or how well it works. You are asking people to time box something because either the details are irrelevant or there is no trust in people to make the right decisions.&lt;/p&gt;

&lt;h2 id=&#34;always-be-releasing:1219c6c1689c6c74fe0a969441c812fa&#34;&gt;Always Be Releasing&lt;/h2&gt;

&lt;p&gt;Releasing functionality does not mean users have to see it. Turning features on and off, experimenting with small audiences, refactoring one class rather than an entire stack; all these are powerful steps for modern companies to improve products. Constant feedback lets everyone know they are headed in the right direction. It lets dev teams know the health of their code base. What is better than actually integrating new code to production to test integration? What is better than knowing if a feature is worth investing in than testing it on a small set of production users?&lt;/p&gt;

&lt;p&gt;I&amp;#8217;m sure you heard about the &lt;a href=&#34;http://en.wikipedia.org/wiki/Cone_of_Uncertainty&#34;&gt;cone of uncertainty&lt;/a&gt;. Small and explicit features with short estimations can be delivered accurately. Larger loosely defined features with long dates are difficult to predict. Break down large features into small, clear user stories. A big feature or a long date means you do not care about details.&lt;/p&gt;

&lt;p&gt;Short date ranges are okay and can help coordinate people. They work well when matched with story size. A few days, one week, one to three, and three to five are good ranges which require a decent discussion to work out details. Ranges allow for adjustment and can be refined as you move along the uncertainty cone. Ideally they are auto-calculated from story points. Anything +5 weeks requires a break down; there are too many variables. Don&amp;#8217;t think you can add up ranges either, that is not the way it works. It is about increasingly clarifying level of detail on what&amp;#8217;s ahead to maintain momentum. You can still, and should, deploy intermittently within the date range. Long dates don&amp;#8217;t provide detail. Without detail you do not care how features work. So you do not care what you get.&lt;/p&gt;

&lt;h2 id=&#34;you-work-for-a-tech-company:1219c6c1689c6c74fe0a969441c812fa&#34;&gt;You Work For A Tech Company&lt;/h2&gt;

&lt;p&gt;Your type of business does not matter. Your size does not matter. In house, off shore, outsourced development does not matter. It&amp;#8217;s 2012. Your company uses technology to do business. You work for a tech company. As a tech person your job is to help your business realize this. As a stakeholder your job is to realize this and help your tech team help you do your job faster, better, easier.&lt;/p&gt;

&lt;h2 id=&#34;i-8217-ll-say-it-again-always-be-releasing:1219c6c1689c6c74fe0a969441c812fa&#34;&gt;I&amp;#8217;ll Say It Again: Always Be Releasing.&lt;/h2&gt;

&lt;p&gt;Good companies consistently take their products to the next level. How? They build an incredible manufacturing pipeline. Why is Toyota&amp;#8217;s just-in-time practices so applicable to building software? Because development teams manufacture software. It&amp;#8217;s how the product is built. It&amp;#8217;s how it changes. It&amp;#8217;s how it&amp;#8217;s delivered. It&amp;#8217;s how it&amp;#8217;s fixed. Dev teams buy the land, construct the building, build the robots, define the pipeline, assemble the pieces, run quality control, load up the trucks, deliver and when all that is done they improve. Hopefully the new manufacturing plant allows for easy improvement. Otherwise somebody made a mistake.&lt;/p&gt;

&lt;h2 id=&#34;faster-better-stronger:1219c6c1689c6c74fe0a969441c812fa&#34;&gt;Faster, Better, Stronger&lt;/h2&gt;

&lt;p&gt;It is everyone&amp;#8217;s responsibility to ensure that manufacturing pipeline delivers as efficiently as possible with no flaws. Continuous integration, unit tests, programming languages, server frameworks, agile development, clear vision, well written stories, cohesive vision, user feedback; it all goes into building a solid manufacturing process. You do not need to get it right the first time. You just need to change and improve when needed. Tech leaders ensure they are building the right process for the business. Stakeholders enable and leverage that pipeline effectively. Radical product changes, disconnected vision or tech decisions lead to numerous and slow manufacturing plants.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Dates are bullshit. It&amp;#8217;s about where you are, where you want to be, and what&amp;#8217;s next. That&amp;#8217;s the conversation.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Update: I missed a section of date ranges matching to story points relating to the cone of certainty. Short date ranges are a good tool for predicting near term deliverables and framing what&amp;#8217;s next. These ranges are most effective when your agile tool auto-calculates velocity from story points. Remember, the bigger the complexity, the greater the date range.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Thoughts on Kanban</title>
          <link>http://blog.michaelhamrah.com/2011/12/thoughts-on-kanban/</link>
          <pubDate>Thu, 15 Dec 2011 00:00:00 UTC</pubDate>
          <author>Michael Hamrah</author>
          <guid>http://blog.michaelhamrah.com/2011/12/thoughts-on-kanban/</guid>
          <description>

&lt;p&gt;One of my favorite achievements in the agile/lean world has been the progression from standard Scrum practices to a &lt;a href=&#34;http://en.wikipedia.org/wiki/Kanban_(development)&#34;&gt;Kanban&lt;/a&gt; approach of software development. In fact, Kanban, in my opinion, is such an ideal approach to software development I cannot imagine approaching team-based development any other way.&lt;/p&gt;

&lt;h2 id=&#34;what-8217-s-wrong-with-scrum:d7ec680e7904e258131968165612fab2&#34;&gt;What&amp;#8217;s Wrong With Scrum?&lt;/h2&gt;

&lt;p&gt;Before answering this, I want to mention Kanban came only after altering, tweaking, and refining the Scrum process as much as possible. If anything, Kanban represents a &lt;em&gt;graduation&lt;/em&gt; from Scrum. Scrum worked, and worked well, but it was time to take the approach to the next level. Why? The Scrum process was failing. It became too constrained, too limiting. As I mentioned in my &lt;a href=&#34;http://www.michaelhamrah.com/blog/2008/12/adventures-in-agile-practical-scrum-intro/&#34;&gt;three-year old (as of this writing) post on Scrum&lt;/a&gt; one needs to constantly iterate in refining the practice. Pick one thing that isn&amp;#8217;t working, fix it, and move one. Quite simply, there was nothing with Scrum left to refine except Scrum itself.&lt;/p&gt;

&lt;h3 id=&#34;why-scrum-was-failing:d7ec680e7904e258131968165612fab2&#34;&gt;Why Scrum Was Failing&lt;/h3&gt;

&lt;p&gt;The main issue was simply it was time to break free from the time-boxed approach of sprints. Too much effort went into putting stories into iterations. Too much effort went into managing the process. This process took away from releasing new functionality. &lt;em&gt;Nothing can be more important than releasing new functionality.&lt;/em&gt; Tweaking iteration length did not help; one week caused too many meetings to happen too frequently. Two weeks and the early sprint planning effort was lost on stories which would not occur until the second week. Too much time went into making stories &amp;#8220;the right size&amp;#8221;. Some where too small; not worth discussing in a group. Some were too big but they did not make sense to break down to fit into the iteration. Worse, valuable contributions in meetings only occurred with a few people. This had nothing to do with the quality of dev talent; some really good developers did not jive with the story time/sprint review/retrospective/group think model. Why would they? Who really likes meetings?&lt;/p&gt;

&lt;h3 id=&#34;rethinking-constraints:d7ec680e7904e258131968165612fab2&#34;&gt;Rethinking Constraints&lt;/h3&gt;

&lt;p&gt;Scrum has a specific approach to constraints: limit by time. Focus on what can be accomplished in X timeframe (sprints). Add those sprints into releases. Wash, rinse, repeat. Kanban, however, rethinks constraints. Time is irrelevant; the constraint is how much work can occur at any one time. This is, essentially, your work in progress. Limit your work in work in progress (WIP) to work you can be actively doing at any one time. In order to do new work, old work must be done.&lt;/p&gt;

&lt;h3 id=&#34;always-be-releasing:d7ec680e7904e258131968165612fab2&#34;&gt;Always Be Releasing&lt;/h3&gt;

&lt;p&gt;The beauty of this approach is that it lends itself well to a continuous deployment approach. If you work on something, and work on it until it is done, when it is done, it can be released. So release it. Why wait until an arbitrary date? The development pipeline in Kanban is similar to Scrum. Stories are prioritized, they are sized, they are ready for work, they are developed, they are tested, they are released. The main difference is instead of doing these at set times, they are done &lt;em&gt;just-in-time&lt;/em&gt;. In order to move from one stage of the process (analysis, development, testing, etc) there must be an open &amp;#8220;slot&amp;#8221; in the next stage. This is your WIP limit. If there isn&amp;#8217;t an open slot, it cannot move, and stays as is. People can be focused on moving stories through the pipeline rather than meeting arbitrary deadlines, no matter how those deadlines came to be. Even blocking items can have WIP limits. The idea is simple: you have X resources. Map those resources directly to work items as soon as they are available, and see them through to the end. Then start again.&lt;/p&gt;

&lt;h3 id=&#34;everything-is-just-in-time:d7ec680e7904e258131968165612fab2&#34;&gt;Everything is Just In Time&lt;/h3&gt;

&lt;p&gt;All of the benefits of Scrum are apparent in Kanban. Transparency into what is being worked on and the state of stories. Velocity can still be measured; stories are sized and can be timed through the pipeline. Averages can be calculated over time for approximate release dates. The business can prioritize what is next up to the point of development. Bugs can be weaved into the pipeline as necessary, without having to detract from sprints. With the right build and deploy setup releases can occur as soon as code is merged into the master branch. Standup meetings are still important.&lt;/p&gt;

&lt;h3 id=&#34;the-goal:d7ec680e7904e258131968165612fab2&#34;&gt;The Goal&lt;/h3&gt;

&lt;p&gt;The theory of constraints is nothing new. My first encounter was with &lt;a href=&#34;http://www.amazon.com/Goal-Process-Ongoing-Improvement/dp/0884270610&#34;&gt;The Goal by Eliyahu Goldratt&lt;/a&gt;. The goal, in this case, is to release new functionality as efficiently (not quickly, not regularly; efficiently) as possible. There is a process to this: an idea happens, a request comes in. It is evaluated, it is fleshed out, given a cost. It is planned, implemented, and tested. It is released. Some are small, some are big. Some can be broken down. But in teams large and small, they go from inception to implementation to release. Value must be delivered efficiently. It can happen quickly, but it does not need to be arbitrarily time-boxed.&lt;/p&gt;

&lt;p&gt;Scrum is a great and effective approach to software development. It helps focus the business and dev teams on thinking about what is next. It is a great way to get teams on board with a goal and working, in sync, together. It follows a predictable pattern to what will happen when. It offers the constraint of time. Kanban offers the constraint of capacity. For software development this is a far more effective constraint to managing work. You still need solid, manageable stories. You just don&amp;#8217;t have to fit a square peg in a round hole. Kanban streamlines the development process so resources, which always have a fixed limit, are the real limit you are dealing with. They are matched directly to the current state of work so a continuous stream of value can be delivered without the stop-and-go Scrum approach.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Scrum Tips: Managing Task Items</title>
          <link>http://blog.michaelhamrah.com/2009/03/scrum-tips-managing-task-items/</link>
          <pubDate>Wed, 11 Mar 2009 00:00:00 UTC</pubDate>
          <author>Michael Hamrah</author>
          <guid>http://blog.michaelhamrah.com/2009/03/scrum-tips-managing-task-items/</guid>
          <description>

&lt;p&gt;One of the biggest hurdles in transitioning to scrum is getting everyone- especially the dev team- on the same page.  Sprint planning and even scrum meetings can be painfully boring and seem useless.  There&amp;#8217;s a lack of understanding of what to do, communication is either too little or too much, and a few people bad mouth the process and continue their heads down development.  You&amp;#8217;re left wondering what&amp;#8217;s the point- thinking it&amp;#8217;s never going to work.  Well, have faith: proper task management is key in making scrum work for you and your team.  Task management is an aspect of scrum that&amp;#8217;s entirely contained within the dev group, which makes implementation a lot easier.&lt;/p&gt;

&lt;h4 id=&#34;have-a-purpose:8e5df32093653ec1649dd5400ba44174&#34;&gt;Have a Purpose&lt;/h4&gt;

&lt;p&gt;The key is you- the scrummaster- need to provide an environment (like a framework) for scrum.  If you think by simply sending some scrum info around, meeting every day, and having a backlog will magically make everything better you&amp;#8217;re wrong and you&amp;#8217;ll fail.  You&amp;#8217;ll also make everyone miserable.  The reason why &amp;#8220;It gets worse before it gets better&amp;#8221; is because it takes time to transition the team into the scrum process.  The key to success is facilitating that transition as quickly as possible, and the solution is having a purpose for everything you do.&lt;/p&gt;

&lt;p&gt;That purpose comes via two simple rules which will help you and your team transition to scrum faster:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;All developers should work on the same backlog item.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No task item should take more than four hours.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Think of these rules as grease in the wheels of scrum.  It keeps the machine moving.&lt;/p&gt;

&lt;h4 id=&#34;a-quick-refresher:8e5df32093653ec1649dd5400ba44174&#34;&gt;A Quick Refresher&lt;/h4&gt;

&lt;p&gt;A backlog item and task item are two different things.  A backlog item is something that&amp;#8217;s business focused.  It&amp;#8217;s specifically created by the product owner for the development team to implement.  It&amp;#8217;s not, and shouldn&amp;#8217;t be, developer focused in any way.  A task item, on the other hand, is developer focused.  It&amp;#8217;s a list of things needed to be done to finish a backlog item.  Task items are created in either a sprint planning or a developer meeting at the start of a sprint.  They can also be refactored in the middle of the sprint.&lt;/p&gt;

&lt;p&gt;A crucial step in scrum is having the team gauge complexity of backlog items.  This requires developers to have an understanding of what needs to be done from a user perspective- which is not something developers are usually good at.  Without understanding what needs to be done, they don&amp;#8217;t know how to do it, and they can&amp;#8217;t tell you how long it will take.  Another popular excuse is &amp;#8220;I need to start coding to figure this out&amp;#8221;.&lt;/p&gt;

&lt;p&gt;The key is to make developers think and plan first so there are fewer variables mid sprint.  This is not mini-waterfall.  It&amp;#8217;s strategy.&lt;/p&gt;

&lt;h4 id=&#34;how-the-rules-help:8e5df32093653ec1649dd5400ba44174&#34;&gt;How the Rules Help&lt;/h4&gt;

&lt;p&gt;Having everyone work on the same item is essential for scrum.  Why? If people are working on different items there&amp;#8217;s little reason for them to communicate.  If Developer A is working on feature X, and Developer B is working on feature Y, there&amp;#8217;s no reason for A or B to care what the other is doing.  In fact, it&amp;#8217;s a waste of time.  However, if both A and B are working on feature X, there&amp;#8217;s every reason in the world for the two to talk.  Not only talk, but collaborate.  It&amp;#8217;s very XP without the side by side awkwardness.  The major benefit is the entire team is focused on the highest priority item- which means something will get completed in the sprint.  By working on single items together each item gets finished faster.  QA has more time to test- and they do it one at a time rather than dealing with multiple things coming together at the end of the sprint.&lt;/p&gt;

&lt;h4 id=&#34;break-things-down:8e5df32093653ec1649dd5400ba44174&#34;&gt;Break Things Down&lt;/h4&gt;

&lt;p&gt;The four hour rule is key to facilitate working together.  By breaking down every task into small pieces, more analysis is done on each backlog item.  The trick is each task is a single thing which can be done and checked in-  a class creation, a new method- all with unit tests.  The benefits materialize in different ways.  First, sprint planning becomes much more effective as communication occurs via the process of breaking down items.  Analysis is done and development ideas are thought out and debated amongst team members.  A roadmap is created outlining steps needed to complete each item- everyone is in the know and on the bus.&lt;/p&gt;

&lt;p&gt;Why four hours? Easy: in theory, a developer should be able to get two four-hour tasks done between scrums.  A developer should never be in a position to say, &amp;#8220;I&amp;#8217;m working on X, and I&amp;#8217;m still planning on working on X&amp;#8221;.   (Unless, of course, they fall behind- in which case, break down the task again).  The point is you want to focus on granularity.  If you have to do a controller, a task of &amp;#8220;Write a controller&amp;#8221; is not adequate.  What are you doing? What actions are needed? What dependencies are there? Are you using ModelBinders, or method parameters? Where&amp;#8217;s the error handling, if any?  The API and code structure evolves out of granular task items- and the whole team is part of the process, everyone on the same page as to what needs to get done. This level of discussion, collaboration, and task tracking are what you&amp;#8217;re looking for.&lt;/p&gt;

&lt;p&gt;Of course, it&amp;#8217;s hard to get the entire team working on backlog items when they&amp;#8217;re small.  It&amp;#8217;s really your judgment call- but in my experience, there are only a few tasks which are too small to be worked on by more than one person in less than four hours.  The end of completing a backlog item is the most difficult when it&amp;#8217;s a lot of little to dos.  But the things which take longer then they should are always the items worked on by one person- which usually aren&amp;#8217;t properly tasked out.  The bottom line is there&amp;#8217;s a constant cycle of breaking things down and redistribution.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TDD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A key factor to success is TDD.  TDD allows isolation of the moving parts.  In this way, a developer can work on a class, a method, or a service without having to worry about dependent objects.  The task description and sprint planning identify what the moving parts are, and how the moving parts fit together.  TDD is the environment to implement those moving parts, and make sure expectations are being met.  You&amp;#8217;ll usually end up rewriting task items mid sprint.  That&amp;#8217;s okay.  Sprint planing is really about establishing guidelines for development.  TDD is where the code and project materializes, and you need to change course when necessary as the project evolves.&lt;/p&gt;

&lt;p&gt;Unit Tests provide a great way to review code.  If you&amp;#8217;re working on a data layer for a business object, the business object developer can look at the data layer tests and get all the usage available.  Little time is spent &amp;#8220;figuring it out&amp;#8221;.  And if the business object developers mock objects don&amp;#8217;t match the concrete ones, somebody wasn&amp;#8217;t on the same page.  However, with small, iterative tasks taking a step back and refactoring is a non-issue.&lt;/p&gt;

&lt;h4 id=&#34;a-better-perspective-from-above:8e5df32093653ec1649dd5400ba44174&#34;&gt;A Better Perspective from Above&lt;/h4&gt;

&lt;p&gt;A great result of this process is the development lead or architect has great insight to how the application shapes up.  During sprint plannings, guidelines can be set on how to implement backlog items.  If something isn&amp;#8217;t tasked out correctly, point out the issue and discuss.  Dependencies can be identified and spun off into new classes.  When issues arise during scrums, refactoring can happen and new directions can be taken- all in the presence of senior devs, which minimize one offs or crazy spaghetti code.  BTW writing spaghetti code is nearly impossible- it&amp;#8217;s hard to make a mess in less than four hours when you&amp;#8217;re only doing one specific thing and everyone is watching.&lt;/p&gt;

&lt;h4 id=&#34;mentoring:8e5df32093653ec1649dd5400ba44174&#34;&gt;Mentoring&lt;/h4&gt;

&lt;p&gt;This process works great for junior developers- they can learn from the entire team.  Similar to an architect having insight to a system, a junior developer has better access to seasoned developers.  One on one time is reduced in favor sprint planning and scrums.  Their work can be evaluated when code comes together for a backlog item.  Any developer is capable of answering a question because everyone is working on the same thing.&lt;/p&gt;

&lt;h4 id=&#34;cleaner-code:8e5df32093653ec1649dd5400ba44174&#34;&gt;Cleaner Code&lt;/h4&gt;

&lt;p&gt;Code reviews happen naturally when code is shared for feature development.  Consider the usual application stack: UI, Controller, Application, Domain, Data Layer.   This stack is no longer in the hands of one person, who either blurs the line between layers or creates a million helper classes.  Code review happens when the pieces gets fused together.  If the puzzle pieces don&amp;#8217;t fit, refactor.  They usually will fit because everyone is clear on task items- because they were small, granular, and created together.&lt;/p&gt;

&lt;p&gt;No one person is left to the whim of their own devices- the expectation is clear and apparent to the team during scrums.  And the best developers have a better surface area for showing off, by being exposed to the entire application and not regulated to a single feature. You&amp;#8217;ll also get better exposure to cross functional teams, like UI.  When the Javascript developer and the backend developer are in the same room, creating the same roadmap, knowing what needs to be done, development is truly fluid.&lt;/p&gt;

&lt;h4 id=&#34;conclusion:8e5df32093653ec1649dd5400ba44174&#34;&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;Scrum, at its core, is really about structure.  Each part is an important gear on the clock which helps the hands move smoothly.  A key to getting the team working in that structure is setting up an environment that meets the .  Task management is key for managing developers and the sprint.  The four hour task breakdown and single item focus are two tools for managing complexity and fostering communication.  The end result are the following benefits:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Better gauge complexity of backlog items.&lt;/li&gt;
&lt;li&gt;Complete work in priority order.&lt;/li&gt;
&lt;li&gt;Fully meet Got Done criteria at end of sprint.&lt;/li&gt;
&lt;li&gt;Understand where things are with development mid-sprint.&lt;/li&gt;
&lt;li&gt;Understand why things are delayed with development mid-sprint.&lt;/li&gt;
&lt;li&gt;Fix cohesion with development.  Specifically, enforce development standards and architecture guidelines, write clean code, and minimize hacks and bugs.&lt;/li&gt;
&lt;li&gt;Top down visibility for architects, bottom up visibility for developers.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Remember, task management is only part of the entire scrum process.  In order for scrum to be effective, everything must fall into place.  But task management will have an immediate benefit for you and your development team.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.dotnetkicks.com/kick/?url=http%3a%2f%2fwww.michaelhamrah.com%2fblog%2findex.php%2f2009%2f03%2fscrum-tips-managing-task-items%2f&#34;&gt;&lt;img src=&#34;http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=http%3a%2f%2fwww.michaelhamrah.com%2fblog%2findex.php%2f2009%2f03%2fscrum-tips-managing-task-items%2f&amp;bgcolor=000099&#34; border=&#34;0&#34; alt=&#34;kick it on DotNetKicks.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Adventures in Agile: Practical Scrum (Intro)</title>
          <link>http://blog.michaelhamrah.com/2008/12/adventures-in-agile-practical-scrum-intro/</link>
          <pubDate>Wed, 03 Dec 2008 00:00:00 UTC</pubDate>
          <author>Michael Hamrah</author>
          <guid>http://blog.michaelhamrah.com/2008/12/adventures-in-agile-practical-scrum-intro/</guid>
          <description>&lt;p&gt;&lt;em&gt;Disclaimer: I am not a certified scrummaster, nor have I taken any formal scrum classes.  I have, however, worked with scrum a great deal at my job, and wanted to share my experiences.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s face it: Scrum is a Utopian pipe dream.  The user stories, working in sprints, task estimations, no deadlines, uncommitted backlog, visibility, transparency, business buy-in, everyone&amp;#8217;s happy, fast development, easily responding to change, everyone gets what they want, everybody gets it and works together- it&amp;#8217;s all a hot air and completely unrealistic.&lt;/p&gt;

&lt;p&gt;Okay, so maybe that&amp;#8217;s a little bit harsh.  How about this argument- real Scrum- true Scrum- ideal Scrum- is a Utopian dream.  It&amp;#8217;s a never ending struggle for a more perfect union.  The essential problem is we, as humans, are incapable of living up to the requirements of ideal Scrum; and business mentality will never allow Scrum to work in the practical world.  It&amp;#8217;s a round peg in a square hole.  But if you believe- and try- you can get partly there, and that, my friends, will be good enough.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Utopian&lt;/strong&gt; &lt;strong&gt;Scrum&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Scrum is dependent on the cohesion of too many disparate factors- mostly three sets of opposing forces.  First, the difference between practical feasibility and the unrealistic demands of requirements; second, the need for &amp;#8220;When can I get it?&amp;#8221; delivery dates from the business versus the complete impossibility of defining those dates accurately; and third, the need for a group of people to fluidly communicate and work together in a variety of situations.&lt;/p&gt;

&lt;p&gt;Scrum works- and delivers- when these three completely impossible scenarios are met.  Scrum simply sets groundrules on how these groups of people interact and manage their work.  But that requires disparate groups of people working and interacting effectively.  Unfortunately, most of the time, it&amp;#8217;s doesn&amp;#8217;t fully happen.  The business will never be satisfied with vague, long term deliverable goals.  The business wants concrete information so they can make decisions- they want to know when product &amp;#8220;A&amp;#8221; will be ready for launch so they can do x, y and z and estimate revenues.  An uncommitted backlog? Story points? WTF is that?  Nor will the business ever fully comprehend the cost/benefit analysis that goes into any sort of feature development.  What do you mean let&amp;#8217;s wait and see? I want to know what it&amp;#8217;s going to be like now! It needs to do x, y and z be be super simple to use- can&amp;#8217;t we just have it do this other thing?  Why will that take so long? I want to tell you how to do it- and if you already do it, why would we change it? I know how it should work!&lt;/p&gt;

&lt;p&gt;My personal favorite is the working together part.  Do you really think it&amp;#8217;s possible to get a group of introverts- all with their own egos and insecurities- to proactively communicate, share ideas, and work effectively as a team?  Heads down, opinionated, or really quiet developers?  This is the &amp;#8220;this conversation is too simplistic for me&amp;#8221; crowd! The &amp;#8220;I talk in code&amp;#8221; crowd!  And everyone on the team can operate without high level direction- and figure out requirements- and bring up impediments or issues when they arise- and ask questions- crowd?  Yeah, right! These are programmers!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Practical Scrum&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Don&amp;#8217;t worry- all is not lost.  The principals of Scrum are pretty solid and good ideas, and even if you only get half way there, you&amp;#8217;re better off than with anything else.  Visibility and transparency are extremely important with any development group, and knowing where you stand with the big picture is solid information anyone can appreciate.  Most of the time the business doesn&amp;#8217;t really care about when things happen, they just want an accurate estimate for planning.  Who wouldn&amp;#8217;t want that?  When you hit your stride with Scrum, it may not be perfect- but both you, the development team, and the business- are all better off because everyone gets enough of what they need with a manageable amount of overhead.&lt;/p&gt;

&lt;p&gt;The main problem with Scrum is that in principal everything make sense.  It&amp;#8217;s easy to see how it works- the backlog, the sprint, the scrum, the estimations- but when you try to do it, everything false apart. In practical terms, it&amp;#8217;s impossible to make all the chips falls as they need to- to make everyone understand what they need to do- and to get everyone in the organization on the same page.  Most people either end up with a bastardization of the process, or worse give up out of frustration.&lt;/p&gt;

&lt;p&gt;Practical Scrum is that middle ground between where you are now and Utopian Scrum.  It&amp;#8217;s the half way of making what you have work, and like Scrum, iterating to a better place one thing at a time.  Practical Scum is simply understanding how to implement Scrum to make your organization work effectively.  The key is not jumping into the deep end with Scrum hoping you know how to swim.  Hint: You&amp;#8217;ll drown.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ll delve into various aspects of Practical Scrum in future posts.  For now, it&amp;#8217;s important to remember a couple of things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Don&amp;#8217;t give up.  If it doesn&amp;#8217;t work, don&amp;#8217;t worry, it usually doesn&amp;#8217;t.&lt;/li&gt;
&lt;li&gt;Scrum is easy in principal; in practicality, it&amp;#8217;s extremely difficult.&lt;/li&gt;
&lt;li&gt;Like everything, you need to move in baby steps when adopting Scrum.&lt;/li&gt;
&lt;li&gt;Remember: If you do it, they will come. This simply means once your team is on Scrum, and you start delivering, people will recognize it works.&lt;/li&gt;
&lt;li&gt;The goal isn&amp;#8217;t learning Scrum- or what Scrum is.  The goal is learning how to adopt scrum.  Like the principals of Scrum, go with the flow.  Iterate.  Make subtle improvements.  Get to where you need to be at a healthy pace.&lt;/li&gt;
&lt;li&gt;Don&amp;#8217;t rush it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;#8217;ll dig into how you get to where you need to be in Scrum in future posts.  I&amp;#8217;ve been on the brink of giving up too, but am happy I&amp;#8217;ve stuck with it.  Now we&amp;#8217;re starting to hit our stride, and it&amp;#8217;s great.  Yes, it&amp;#8217;s still rough around the edges, but that&amp;#8217;s a fact of life with everything.&lt;/p&gt;

&lt;p&gt;Getting there isn&amp;#8217;t half the battle- it is the battle.&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
