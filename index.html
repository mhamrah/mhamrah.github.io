<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Adventures in HttpContext &middot; All the stuff after &#39;Hello, World&#39;
    
  </title>

  
  <link rel="stylesheet" href="http://blog.michaelhamrah.com/css/poole.css">
  <link rel="stylesheet" href="http://blog.michaelhamrah.com/css/syntax.css">
  <link rel="stylesheet" href="http://blog.michaelhamrah.com/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://blog.michaelhamrah.com/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="http://blog.michaelhamrah.com/assets/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://blog.michaelhamrah.com/atom.xml">
</head>


  <body>

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Michael Hamrah</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item  active " href="http://blog.michaelhamrah.com/">Home</a>
    <a class="sidebar-nav-item " href="http://blog.michaelhamrah.com/post">Posts</a>

    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a class="sidebar-nav-item " href="http://blog.michaelhamrah.com/about/">About</a>
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="http://linkedin.com/in/hamrah">LinkedIn</a>
    <a class="sidebar-nav-item" href="http://twitter.com/mhamrah">@mhamrah</a>
    <a class="sidebar-nav-item" href="http://github.com/mhamrah">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="http://blog.michaelhamrah.com/" title="Home">Adventures in HttpContext</a>
            <small>All the stuff after &#39;Hello, World&#39;</small>
          </h3>
        </div>
      </div>

      <div class="container content">





<div class="posts">
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/06/fleet-unit-files-for-kubernetes-on-coreos/">Fleet Unit Files for Kubernetes on CoreOS</a></h1>
        <span class="post-date">Jun 27 2015</span>
        <p>As I&#8217;ve been leveraging CoreOS more and more for running docker containers, the limitations of Fleet have become apparent.</p>

<p>Despite the benefits of <a href="http://blog.michaelhamrah.com/2015/04/easy-scaling-with-fleet-and-coreos/">dynamic unit files via the Fleet API</a> there is still a need for fine-grained scheduling, discovery, and more complex dependencies across containers. Thus I&#8217;ve been exploring Kubernetes. Although young, it shows promise for practical usage. The <a href="https://github.com/GoogleCloudPlatform/kubernetes">Kubernetes repository</a> has a plethora of &#8220;getting started&#8221; examples across a variety of environments. There are a few CoreOS related already, but they embed the kubernetes units in a cloud-config file, which may not be what you want.</p>

<p>My preference is to separate the CoreOS cluster setup from the Kubernetes installation. Keeping your CoreOS cloud-config minimal has many benefits, especially on AWS where you can&#8217;t easily update your cloud-config. Plus, you may already have a CoreOS cluster and you just want to deploy Kubernetes on top of it.</p>

<p>The <a href="https://github.com/mhamrah/kubernetes-coreos-units">Fleet Unit Files for Kubernetes on CoreOS are on GitHub</a>. The unit files makes a few assumptions, mainly you are running with a <a href="https://coreos.com/docs/cluster-management/setup/cluster-architectures/#production-cluster-with-central-services">production setup using central services</a>. For AWS <a href="http://blog.michaelhamrah.com/2015/03/managing-coreos-clusters-on-aws-with-cloudformation/">you can use Cloudformation to manage multiple sets of CoreOS roles as distinct stacks, and join them together via input parameters</a>.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/05/networking-basics-understanding-cidr-notation-and-subnets-whats-up-with-16-and-24/">Networking Basics: Understanding CIDR notation and Subnets: whatâ€™s up with /16 and /24?</a></h1>
        <span class="post-date">May 12 2015</span>
        <p>An IP address (specifically, an IPv4 address), like 192.168.1.51, is really just 32 bits of data. 32 ordinary bits, like a 32 bit integer, but represented a little differently than a normal int32. These 32 bits are split up into 4 8-bit blocks, with each block represented as a number with a dot in between. This is called dotted-decimal notation: 192.168.1.51. Curious why an IP address never has a number in it greater than 255? That&#8217;s the maximum value for 8 bits of data: you can only represent 0 to 255 with 8 bits.</p>

<p>The IP address 192.168.1.51 in binary is 11000000 10101000 00000001 00110011, or just 11000000101010000000000100110011. If this were an int32 it would be 3232235827. Why not just use this number as an address? By breaking up the address into blocks we can logically group related ip addresses together. This is helpful for routing and subnets (as in sub-networks) which is where we usually see <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR notation</a>. It lets us specify a common range of IP address by saying some bits in the IP address are fixed, while others can change. When we add a slash and a number between 0 and 32 after an IP, like 192.168.1.<sup>1</sup>&frasl;<sub>24</sub>, we specify which bits of the address are fixed and which can be changed.</p>

<p>Let&#8217;s take a look at Docker networking. Docker creates a subnet for all containers on a machine. It uses CIDR notation to specify a range of IP address for containers, usually 172.17.42.<sup>1</sup>&frasl;<sub>16</sub>. The /16 tells us the first sixteen bits in the dotted-decimal ip address are fixed. So any ip address, in binary, must begin with 1010110000010001. We are &#8220;masking&#8221; the first 16 bits of the address. Docker could assign a container of 172.23.42.1 but could not assign it 172.32.42.1. That&#8217;s because the first four bits in 23 are the same as 17 (0001) but the first four bits 32 are different (0010).</p>

<p>Another way to specify a range of IP addresses is with a &#8220;subnet mask&#8221;. Instead of simply saying 172.17.42.<sup>1</sup>&frasl;<sub>16</sub>, we could give the ip address of 172.17.42.1 and a subnet mask of 255.255.0.0. We often see this with tools like <code>ifconfig</code>.</p>

<p>255.255.0.0 in binary is 11111111 11111111 00000000 00000000. The first sixteen bits are 1 telling us which bits in the corresponding IP address are fixed. Sometimes you see a subnet mask of 255.240.0.0: that&#8217;s the same as an ip range of /12. The number 240 is 11110000 in binary, masking the first 12 bits in the subnet mask 255.240.0.0 (8 1&#8217;s for 255, and 4 1&#8217;s for 240). You could never have a subnet of 239, because there is a 0 in the middle of the binary number 239 (11101111), defeating the purpose of a mask.</p>

<p>A /16 range gives us 2 8 bit blocks to play with, or 65535 combinations: 2^16, or 256*256. But the 0 and 255 numbers are reserved in the IP address space, so we really only get 254 * 254 combinations, or 64516 addresses. This is important when setting up networks: if you want to make sure you have enough IP addresses for all the things in your network. A software defined network like <a href="https://github.com/coreos/flannel">Flannel</a>, which allows you to create a private subnet for docker containers across hosts, uses a /16 subnet for a cluster and /24 range per node. So an entire cluster can only have 64516 ip address. More specifically, it can only have 254 nodes running 254 containers. Large networks, like those at most companies, use the reserved address space 10.0.0.0/8. The first 8 bits are fixed giving us 24 bits to play with: or 16,387,064 possible addresses (because we can&#8217;t use 0 or 255). These are usually broken up into several subnet works, like 10.252.0.0/16 and 10.12.0.0/16, carving up smaller subnets from the larger address space.</p>

<p>Subnet masks and CIDR notation play prominent roles in a variety of areas beyond specifying subnets. They are heavily used in routing tables to specify where traffic for a particular IP should go. They are used extensively in AWS and other cloud providers to specify firewall rules for security groups as well as their VPC product. Understanding CIDR notion and subnet masks make other aspects of networking: interfaces, gateways, routing tables much easier to understand.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/04/easy-scaling-with-fleet-and-coreos/">Easy Scaling with Fleet and CoreOS</a></h1>
        <span class="post-date">Apr 10 2015</span>
        <p>One element of a successful production deployment is the ability to easily scale the number of instances your process is running. Many cloud providers, both on the PaaS and IaaS front, offer such functionality: AWS Auto Scaling Groups, Heroku&#8217;s process size, Marathon&#8217;s instance count. I was hoping for something similar in the CoreOS world. <a href="http://deis.io">Deis</a>, the PaaS-on-CoreOS service, offers Heroku-like scaling, but I don&#8217;t want to commit to the Deis layer nor its build pack approach (for no other reason than personal preference). Fleet, CoreOS&#8217;s distributed systemd service, offers service templating, but you cannot say &#8220;now run three instances of service x&#8221;. Being programmers we can do whatever we want, and luckily, we&#8217;re only a little bash script away from replicating the &#8220;scale to x instances&#8221; functionality of popular providers.</p>

<p><a href="http://blog.michaelhamrah.com/2015/03/deploying-docker-containers-on-coreos-with-the-fleet-api/">You&#8217;ll want to enable the Fleet HTTP Api</a> for this script to work. You can easily port this to the Fleet CLI, but I much prefer the http api because it doesn&#8217;t involve ssh, and provides more versatility into how and where you run the script.</p>

<p>Conceptually the flow is straightforward:</p>

<ul>
<li>Given a process we want to set the number of running instances to some <code>desired_count</code>.</li>
<li>If <code>desired_count</code> is less than <code>current_count</code>, scale down.</li>
<li>If <code>desired_count</code> is more than <code>current_count</code>, scale up.</li>
<li>If they are the same, do nothing.</li>
</ul>

<p>Fleet offers service templating so you can have a service unit named <code>my_awesome_app@.service</code> with specific copies named <code>my_awesome_app@1, my_awesome_app@2, my_awesome_app@N</code> representing specific running instances. Currently Fleet doesn&#8217;t offer a way to group these related services together but we can easily pattern match on the service name to control specific running instances. The steps are straightforward:</p>

<ul>
<li>Query the Fleet API for all instances</li>
<li>Filter by all services matching the specified name</li>
<li>See how many instances we have running for the given service</li>
<li>Destroy or create instances using specific service names until we match the <code>desired_size</code>.</li>
</ul>

<p>All of these steps are easily achievable with Fleet&#8217;s HTTP Api (or fleetctl) and a little bash. To give our script some context, let&#8217;s start with how we want to use the script. Ideally it will look like this:</p>

<pre class="toolbar-overlay:false syntax bash">./scale-fleet my_awesome_app 5
</pre>

<p>First, let&#8217;s set up our script <code>scale-fleet</code> and set the command line arguments:</p>

<pre class="syntax bash">#!/bin/bash

FLEET_HOST=&lt;YOUR FLEET API HOST>

# You may want to consider cli flags 
SERVICE_NAME=$1
DESIRED_SIZE=$2
</pre>

<p>Next we want to query the Fleet API and filter on all units with a prefix of <code>SERVICE_NAME</code> which have a process number. This will give us an array of units matching <code>my_awesome_app@1.service</code>, not the base template of <code>my_awesome_app@.service</code>. These are the units we will either add to or destroy as appropriate. The latest 1.5 version of jq supports regex expressions, but as of this writing 1.4 is the common release version, so we&#8217;ll parse the json response with jq, and then filter with grep. Finally some bash trickery will parse the result into an array we can loop through later.</p>

<pre class="syntax bash"># Curls the API and filter on a specific pattern, storing results in an array
INSTANCES=($(curl -s $FLEET_HOST/fleet/v1/units | jq ".units[].name | select(startswith(\"$SERVICE@\"))" | grep '\w@\d\.service'))

# A bash trick to get size of array
CURRENT_SIZE=${#INSTANCES[@]}
echo "Current instance count for $SERVICE is: $CURRENT_SIZE"
</pre>

<p>Next let&#8217;s scaffold the various scenarios for matching <code>CURRENT_SIZE</code> with <code>DESIRED_SIZE</code>, which boils down to some if statements.</p>

<pre class="syntax bash">if [[ $DESIRED_SIZE = $CURRENT_SIZE ]]; then
  echo "doing nothing, current size is equal desired size"
elif [[ $DESIRED_SIZE &lt; $CURRENT_SIZE ]]; then
  echo "going to scale down instance $CURRENT_SIZE"
  # More stuff here
else 
  echo "going to scale up to $DESIRED_SIZE"
  # More stuff here
fi
</pre>

<p>When the desired size equals the current size we don&rsquo;t need to do anything. Scaling down is easy, we simply loop, deleting the specific instance, until the desired and current states match. You can drop in the following snippet for scaling down:</p>

<pre class="syntax bash">until [[ $DESIRED_SIZE = $CURRENT_SIZE ]]; do
    curl -X DELETE $FLEET_HOST/fleet/v1/units/${SERVICE}@${CURRENT_SIZE}.service

    let CURRENT_SIZE = CURRENT_SIZE-1
  done
  echo "new instance count is $CURRENT_SIZE"
</pre>

<p>Scaling up is a bit trickier. Unfortunately you can&rsquo;t simply create a new unit from a template like you can with the fleetctl CLI. But you can do exactly what the fleetctl does: copy the body from the base template and create a new one with the specific full unit name. With the body we can loop, creating instances, until our current size matches the desired size. Let&rsquo;s walk it through step-by-step:</p>

<pre class="syntax bash">echo "going to scale up to $desired_size"
 # Get payload by parsing the options field from the base template
 # And build our new payload for PUTing later
 payload=`curl -s $FLEET_HOST/fleet/v1/units/${SERVICE}@.service | jq '. | { "desiredState":"launched", "options": .options }'`

 #Loop, PUTing our new template with the appropriate name
 until [[ $DESIRED_SIZE = $CURRENT_SIZE ]]; do
   let current_size=current_size+1

   curl -X PUT -d "${payload}" -H 'Content-Type: application/json' $FLEET_HOST/fleet/v1/units/${SERVICE}@${CURRENT_SIZE}.service 
 done
 echo "new instance count is $CURRENT_SIZE"
</pre>

<p>With our script in place we can scale away:</p>

<pre class="syntax bash"># Scale up to 5 instances
$ ./scale-fleet my_awesome_app 5

# Scale down
$ ./scale-fleet my_awesome_app 3
</pre>

<p>Because this all comes down to a simple bash script you can easily run it from a variety of places. It can be part of a parameterized Jambi job to scale manually with a UI, part of an <a href="http://github.com/hashicorp/envconsul">envconsul</a> setup with a key set in <a href="consul.io">Consul</a>, or it can fit into a larger script that reads performance characteristics from some monitoring tool and reacts accordingly. You can also combine this with AWS Cloudformation or another cloud provider: if you&rsquo;re CPU&rsquo;s hit a certain threshold, you can scale the specific worker role running your instances, and have your <code>desired_size</code> be some factor of that number.</p>

<p>I&rsquo;ve been on a bash kick lately. It&rsquo;s a versatile scripting language that easily portable. The syntax can be somewhat mystic, but as long as you have a shell, you have all you need to run your script.</p>

<p>The final, complete script is here:</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/03/managing-coreos-clusters-on-aws-with-cloudformation/">Managing CoreOS Clusters on AWS with CloudFormation</a></h1>
        <span class="post-date">Mar 25 2015</span>
        <p>Personally, I find CloudFormation a somewhat annoying tool, yet I haven&#8217;t replaced it with anything else. Those json files can get so ugly and unwieldy. Alternatives exist; you can try an abstraction like <a href="https://github.com/cloudtools/troposphere">troposphere</a> or <a href="https://jclouds.apache.org">jclouds</a>, or ditch cfn completely with something like <a href="https://www.terraform.io">terraform</a>. These are interesting tools but somehow I find myself sticking with the straight-up json approach, the aws cli, and some bash scripting: the pieces are already there, they just need to be strung together. In the end it&#8217;s not that bad, and there are some tools and techniques I&#8217;ve picked up which really help out. I recently applied these to managing CoreOS clusters with CFN, and wanted to share a simplified version of the approach.</p>

<p><a href="https://coreos.com/docs/running-coreos/cloud-providers/ec2/">CoreOS provides a default CloudFormation template</a> which is a great start for cluster experimentation. But scaling out, where nodes are coming and going, can be disastrous for etcd&#8217;s quorum consensus if you&#8217;re not careful. You just don&#8217;t want to remove nodes from a formed etcd cluster. <a href="https://coreos.com/docs/cluster-management/setup/cluster-architectures/">CoreOS&#8217;s cluster documentation</a> has a section on production configuration: you want a core set of nodes for running central services, with various worker nodes for specific purposes. We can elaborate this with a short-list of requirements:</p>

<p><em><strong>You want to tag sets of instances with specific roles so you can group dependencies and isolate apps when needed.</strong></em> Although possible, it&#8217;s unrealistic to actually run any app on any node. More likely you want to group apps into front-facing and back-facing and treat those nodes differently. For instance, you could map the IP&#8217;s of front-facing nodes to a Route53 endpoint.</p>

<p><em><strong>You want a cluster of heterogeneous instances for different workloads</strong></em> Certain apps require certain characteristics. Even though you&#8217;re running everything in docker containers, you still want to have c4&#8217;s for compute-intensive loads, r3&#8217;s for memory-intensive loads, etc. Look at your applications and map them to a system topology. You can also scale these groups of instances differently, but you want to see your entire system as a whole: not as independent, discrete parts.</p>

<p><em><strong>At some point, you&#8217;ll need to update the configuration of your instances. You want to do this surgically, without accidentally destroying your cluster</strong></em>. You may be one bad cfn update from relaunching an auto scaling group or misconfiguring an instance which causes a replacement. Just like normal instances you want to apply updates and reconfiguration of nodes in a sane, logical way. If you only had one cfn template for your entire cluster, it&#8217;s all or nothing. That&#8217;s not a choice we want to make.</p>

<p>CoreOS won&#8217;t let you forget about the underlying nodes; it just adds a little abstraction so you don&#8217;t need to deal with specific nodes as much.</p>

<p>I&#8217;m assuming you&#8217;re familiar with CloudFormation and the basics of a template. For our setup we&#8217;ll start with the <a href="https://s3.amazonaws.com/coreos.com/dist/aws/coreos-stable-hvm.template">us-east-1 hvm CoreOS template</a> and modify it along the way. This template create a straight-up CoreOS cluster launched in an Auto Scaling Group, uses a LaunchConfig&#8217;s UserData to set some Cloud-Config settings. Like most templates you need a few parameters to launch. The non-default ones are your keypair and the etcd Discovery Url for forming the cluster. We are going to launch this stack with the CLI (who needs user interfaces?)</p>

<p>Let&#8217;s create a bash script, <code>coreos-cfn.sh</code>, to call our create stack (don&#8217;t forget to chmod +x). We need a DiscoveryUrl so we&#8217;ll get a new one in our script and pass it as a parameter to CFN.</p>

<pre class="syntax bash">#!/bin/bash 

DISCOVERY_URL=`curl -s -w "\n" https://discovery.etcd.io/new`
#Check to make sure the above command worked, or exit
[[ $? -ne 0 ]] &#038;&#038; echo "Could not generate discovery url." &#038;&#038; exit 1

if [ -z "$COREOS_KEYPAIR" ]; then
  KEYPAIR=yourkey.pem
fi

# Create the CloudFormation stack
aws cloudformation create-stack \
    --stack-name coreos-test \
    --template-body file://coreos-stable-hvm.template \
    --capabilities CAPABILITY_IAM \
    --tags Key=Name,Value=CoreOS \
    --parameters \
        ParameterKey=DiscoveryURL,ParameterValue=${DISCOVERY_URL} \
        ParameterKey=KeyPair,ParameterValue=${KEYPAIR}
</pre>

<p>The <code>-z $KEYPAIR</code> tests to see if there&#8217;s a keypair set as an environment variable; if not, it uses the specified one. If you run <code>coreos-cfn.sh</code> you should see the CLI spit out the ARN for the stack. Before we do that, let&#8217;s make two minor tweaks.</p>

<p>There are two key pieces of information we want to remember from this cluster: The DiscoveryUrl, so can access cluster state, and the AutoScalingGroup, so we can easily inspect instances in the future. Because the DiscoveryUrl is a parameter the aws cli will remember it for you. We need to add the auto scaling group as an output:</p>

<pre class="syntax json">"Outputs": {
    "AutoScalingGroup" : {
      "Value": { "Ref": "CoreOSServerAutoScale" }
    }
  }
</pre>

<p>After launching the cluster we can use the CLI and some jq to get back these parameters. It&#8217;s a simple built-in storage mechanism of AWS, and all you need is the original stack name:</p>

<pre class="syntax bash"># Get back the DiscoveryURL: Describe the stack, select the parameter list
DISCOVERY_URL=`aws cloudformation describe-stacks --stack-name coreos-test | \
  jq -r '[.Stacks[].Parameters[]][] | select (.ParameterKey == "DiscoveryURL") | .ParameterValue'`

# Get back the auto-scaling-group-id
LEADER_ASG=`aws cloudformation describe-stacks --stack-name coreos-test | \
  jq -r '[.Stacks[].Outputs[]][] | select (.OutputKey == "AutoScalingGroup") | .OutputValue'`

echo "Discovery Url is $DISCOVERY_URL and Leader ASG is $LEADER_ASG"
</pre>

<p>Why is this important? Because now we can either inspect the state of the cluster via the disovery url service, or query the ASG to inspect running nodes directly:</p>

<pre class="syntax bash"># Query AWS for Leader Nodes
$aws ec2 describe-instances --filters Name=tag-value,Values=$LEADER_ASG | \
  jq '.Reservations[].Instances[].NetworkInterfaces[].PrivateIpAddress'

# Inspect the Discovery Url for nodes, trimming port. 
$ `curl -s $DISCOVERY_URL | jq '.node.nodes[].value[0:-5]'

# Taking the latter one step further, we can build an Etcd Peers string using Jq, xargs and tr
$ ETCD_PEERS=`curl -s $DISCOVERY_URL | jq '.node.nodes[].value[0:-5]' | xargs -I{}  echo "{}:4001" | tr "\\n" ","`
# Drop the last ,
$ ETCD_PEERS=${ETCD_PEERS%?}
</pre>

<p>Armed with this information we are now able to spin up new CoreOS nodes and have it use our CoreOS leader cluster for management. The <a href="https://coreos.com/docs/cluster-management/setup/cluster-architectures/">CoreOS Cluster Architecture page</a> has the specific <code>cloud-config</code> settings which amount to:</p>

<ul>
<li>Disable etcd, we don&#8217;t need it</li>
<li>Set etcd peer settings to a comma delimited list of nodes for Fleet, Locksmith</li>
<li>Set environment variables for fleet and etcd in start scripts</li>
</ul>

<p>We&#8217;ll make the etcd peer list a parameter for our template. We can duplicate our leader template, replace the <code>UserData</code> portion of the <code>LaunchConfig</code> with the updated settings from the link above, and add <code>{ Ref: }</code> parameters where appropriate. Let&#8217;s also add a metadata parameter as well:</p>

<pre class="syntax json">"Parameters": {
    "EtcdPeers" : {
      "Description" : "A comma delimited list of etcd endpoints to use for state management.",
      "Type" : "String"
    },
    "FleetMetadata" : {
      "Description" : "A comma delimited list of key=value attributes to apply for fleet",
      "Type" : "String"
    }
  }
</pre>

<p>We can use the <code>Ref</code> functionality to pass these to our <code>UserData</code> script of the <code>LaunchConfig</code>:</p>

<pre class="syntax json">//other config above
  "UserData" : { "Fn::Base64":
          { "Fn::Join": [ "", [
            "#cloud-config\n\n",
            "coreos:\n",
            "  fleet:\n",
            "    metadata: ", { "Ref": "FleetMetadata" }, "\n",
            "    etcd_servers: $", { "Ref": "EtcdPeers" }, "\n",
            "  locksmith:\n",
            "    endpoint: ", { "Ref": "EtcdPeers" }, "\n"
            ] ]
          }

// Other config below
</pre>

<p>Finally we need a bash script which lets us inspect the existing stack information to pass as parameters to this new template. I also appreciate a CLI tool with a sane set of explicit flags. When I launch a secondary set of CoreOS nodes, I&#8217;d like something simple to set the name, type, metadata and where I want to join to:</p>

<pre class="syntax bash">$ launch-worker-group.sh -n r3-workers -t r3.large -j coreos-test -m "instancetype=r3,role=worker"
</pre>

<p>Bash has a flag-parsing abilities in its <code>getopts</code> function which we&#8217;ll simply use to set variables:</p>

<pre class="syntax bash">#!/bin/bash

while getopts n:j:m:s: FLAG; do
  case $FLAG in
    n)  STACK_NAME=${OPTARG};;
    j)  JOIN=${OPTARG};;
    m)  METADATA=${OPTARG};;
    t)  INSTANCE_TYPE =${OPTARG};;
    [?])
      print >&#038;2 "Usage: $0 [ -n stack-name ] [ -j join to leader] [ -m fleet-metadata ] [ -t instance-type ]"
      exit 1;;
  esac
done

shift $((OPTIND-1))

# You can set defaults, too:
if [ -z $INSTANCE_TYPE ]; then 
  INSTANCE_TYPE ="m3.medium"
fi
</pre>

<p>With this in place it&#8217;s just a matter of calling the AWS CLI with our new template and updated parameters. The only thing we&#8217;re doing differently than the original script is using CloudFormation&#8217;s json parameter functionality. This allows for more structured data in variables. Otherwise the comma-delimited list for etcd peers will throw off the CLI call.</p>

<pre class="syntax bash">DISCOVERY_URL=`aws cloudformation describe-stacks --stack-name $JOIN | \
  jq -r '[.Stacks[].Parameters[]][] | select (.ParameterKey == "DiscoveryURL") | .ParameterValue'`
# Taking the latter one step further, we can build an Etcd 
# Peers string using jq, xargs and tr to flatten
ETCD_PEERS=`curl -s $DISCOVERY_URL | jq '.node.nodes[].value[0:-5]' | \
  xargs -I{}  echo "{}:4001" | tr "\\n" ","`

# Drop the last ,
ETCD_PEERS=${ETCD_PEERS%?}

 # Create the CloudFormation stack
 aws cloudformation create-stack \
    --stack-name STACK_NAME \
    --template-body file://coreos-worker-hvm.template \
    --capabilities CAPABILITY_IAM \
    --tags Key=Name,Value=CoreOS Key=Role,Value=Worker \
    --parameters "[
      { \"ParameterKey\":\"FleetMetadata\",\"ParameterValue\":\"${METADATA}\" },
      { \"ParameterKey\":\"InstanceType\",\"ParameterValue\":\"${INSTANCE_TYPE}\" },
      { \"ParameterKey\":\"EtcdPeers\",\"ParameterValue\":\"${ETCD_PEERS%?}\" },
      { \"ParameterKey\":\"KeyPair\",\"ParameterValue\":\"${KEYPAIR}\" }
    ]"
</pre>

<p>And launch it! This will create a new stack for your worker nodes with whatever metadata you want, with whatever instance type you want.</p>

<p>There are a few ways to extend this. For one, we haven&#8217;t dealt with updating or destroying the stack. You can create separate shell scripts or combine them together with flags for determining which action to take. I prefer the latter as it keeps all related scripts in one file, but you can break out accordingly. You can use the AWS CLI and the Stack Name to query for private ip&#8217;s and update Route 53 accordingly, bypassing the need for an ELB.</p>

<p>You can do a lot with bash and other CLI tools like jq. You don&#8217;t need to scour GitHub for open source tools, or frameworks that have bells and whistles. The core components are there, you just need to glue them together. Yes, your scripts may get out of hand, but at that point it&#8217;s worth looking for alternatives because there&#8217;s probably a specific problem you need to solve. Remember, be opinionated and let those choices guide you. At some point in the future I may be raving about Terraform; friends say it&#8217;s a great tool, but it&#8217;s just not one that I need-or particularly want-to use now.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/03/slimming-down-dockerfiles-decrease-the-size-of-gitlabs-ci-runner-from-900-to-420-mb/">Slimming down Dockerfiles: Decrease the size of Gitlabâ€™s CI runner from 900 to 420 mb</a></h1>
        <span class="post-date">Mar 22 2015</span>
        

<p>I&#8217;ve been leveraging Gitlab CI for our continuous integration needs, running both the CI site and CI runners on our CoreOS cluster in docker containers. It&#8217;s working well. On the runner side, after cloning the ci-runner repositroy and running a <code>docker build -t base-runner .</code> , I was a little disappointed with the size of the runner. It weighed in at 900MB, a fairly hefty size for something that should be a lightweight process. I&#8217;ve built the <a href="https://github.com/gitlabhq/gitlab-ci-runner/blob/master/Dockerfile">ci-runner dockerfile</a> with the name &#8220;base-runner&#8221;:</p>

<pre class="syntax bash wrap:true">base-runner      latest      aaf8a1c6a6b8    2 weeks ago    901.1 MB
</pre>

<p>The dockerfile is well documented and organized, but I immediately noticed some things which cause dockerfile bloat. There are some great resources on slimming down docker files, including <a href="http://www.centurylinklabs.com/optimizing-docker-images/">optimizing docker images</a> and the <a href="https://github.com/gliderlabs/docker-alpine">docker-alpine</a> project. The advice comes down to:</p>

<ul>
<li>Use the smallest possible base layer (usually Ubuntu is not needed)</li>
<li>Eliminate, or at least reduce, layers</li>
<li>Avoid extraneous cruft, usually due to excessive packages</li>
</ul>

<p>Let&#8217;s make some minor changes to see if we can slim down this image. At the top of the dockerfile, we see the usual apt-get commands:</p>

<pre class="syntax bash wrap:true"># Update your packages and install the ones that are needed to compile Ruby
RUN apt-get update -y
RUN apt-get upgrade -y
RUN apt-get install -y curl libxml2-dev libxslt-dev libcurl4-openssl-dev libreadline6-dev libssl-dev patch build-essential zlib1g-dev openssh-server libyaml-dev libicu-dev

# Download Ruby and compile it
RUN mkdir /tmp/ruby
RUN cd /tmp/ruby &#038;&#038; curl --silent ftp://ftp.ruby-lang.org/pub/ruby/2.0/ruby-2.0.0-p481.tar.gz | tar xz
RUN cd /tmp/ruby/ruby-2.0.0-p481 &#038;&#038; ./configure --disable-install-rdoc &#038;&#038; make install
</pre>

<p>Each <code>RUN</code> command creates a separate layer, and nothing is cleaned up. These artifacts will stay with the container unnecessarily. Running another <code>RUN rm -rf /tmp</code> won&#8217;t help, because the history is still there. We need things gone and without a trace. We can &#8220;flatten&#8221; these commands and add some cleanup commands while preserving readability:</p>

<pre class="syntax bash"># Update your packages and install the ones that are needed to compile Ruby
# Download Ruby and compile it
RUN apt-get update -y &#038;&#038; 
    apt-get upgrade -y &#038;&#038; 
    apt-get install -y curl libxml2-dev libxslt-dev libcurl4-openssl-dev libreadline6-dev libssl-dev patch build-essential zlib1g-dev openssh-server libyaml-dev libicu-dev &#038;&#038; 
    mkdir /tmp/ruby &#038;&#038; 
    cd /tmp/ruby &#038;&#038; curl --silent ftp://ftp.ruby-lang.org/pub/ruby/2.0/ruby-2.0.0-p481.tar.gz | tar xz &#038;&#038; 
    cd /tmp/ruby/ruby-2.0.0-p481 &#038;&#038; ./configure --disable-install-rdoc &#038;&#038; make install &#038;&#038; 
    apt-get clean &#038;&#038; 
    rm -rf /var/lib/apt/lists/* /tmp/*
</pre>

<p>There&#8217;s only one run command, and the last two lines cleanup the apt-get downloads and <code>tmp</code> space. Let&#8217;s see how we well we do:</p>

<pre class="syntax bash wrap:true">$ docker images | grep base-runner
base-runner      latest      2a454f84e4e8      About a minute ago   566.9 MB
</pre>

<p>Not bad; with one simple modification we went from 902mb to 566mb. This change comes at the cost of build speed. Because there&#8217;s no previously cached layer, we always start from the beginning. When creating docker files, I usually start with multiple run commands so history is preserved while I&#8217;m working on the file, but then concatenate everything at the end to minimize cruft.</p>

<p>566mb is a good start, but can we do better? The goal of this build is to install the ci-runner. This requires Ruby and some dependencies, all documented on the ci-runner&#8217;s readme. As long as we&#8217;re meeting those requirements, we&#8217;re good to go. Let&#8217;s switch to debian:wheezy. We&#8217;ll also need to tweak the locale setting for debian. Our updated dockerfile starts with this:</p>

<pre class="syntax bash wrap:true"># gitlab-ci-runner

FROM debian:wheezy
MAINTAINER Michael Hamrah &lt;m@hamrah.com>

# Get rid of the debconf messages
ENV DEBIAN_FRONTEND noninteractive

# Update your packages and install the ones that are needed to compile Ruby
# Download Ruby and compile it
RUN apt-get update -y &#038;&#038; 
    apt-get upgrade -y &#038;&#038; 
    apt-get install -y locales curl libxml2-dev libxslt-dev libcurl4-openssl-dev libreadline6-dev libssl-dev patch build-essential zlib1g-dev openssh-server libyaml-dev libicu-dev &#038;&#038; 
    mkdir /tmp/ruby &#038;&#038; 
    cd /tmp/ruby &#038;&#038; curl --silent ftp://ftp.ruby-lang.org/pub/ruby/2.0/ruby-2.0.0-p481.tar.gz | tar xz &#038;&#038; 
    cd /tmp/ruby/ruby-2.0.0-p481 &#038;&#038; ./configure --disable-install-rdoc &#038;&#038; make install &#038;&#038; 
    apt-get clean &#038;&#038; 
    rm -rf /var/lib/apt/lists/* /tmp/*
</pre>

<p>Let&#8217;s check this switch:</p>

<pre class="syntax bash wrap:true">base-runner      latest      40a1465ebaed      3 minutes ago      490.3 MB
</pre>

<p>Better. A slight modification can slim this down some more; the dockerfile builds ruby from source. Not only does this take longer, it&#8217;s not needed: we can just include the <code>ruby</code> and <code>ruby-dev</code> packages; on debian:wheezy these are good enough for running the ci-runner. By removing the install-from-source commands we can get the image down to:</p>

<pre class="syntax bash wrap:true">base-runner      latest      bb4e6306811d      About a minute ago   423.6 MB
</pre>

<p>This now more than 50% less then the original, with a minimal amount of tweaking.</p>

<h1 id="pushing-even-further:ef76312dca5f3c1992b296f85b019da1">Pushing Even Further</h1>

<p>Normally I&#8217;m not looking for an absolute minimal container. I just want to avoid excessive bloat, and some simple commands can usually go a long way. I also find it best to avoid packages in favor of pre-built binaries. As an example I do a lot of work with Scala, and have an sbt container for builds. If I were to install the SBT package from debian I&#8217;d get a container weighing in at a few hundred megabytes. That&#8217;s because the SBT package pulls in a lot of dependencies: java, for one. But if I already have a jre, all I really need is the sbt jar file and a bash script to launch. That considerably shrinks down the dockerfile size.</p>

<p>When selecting a base image, it&#8217;s important to realize what you&#8217;re getting. A linux distribution is simply the linux kernel and an opinionated configuration of packages, tools and binaries. Ubuntu uses aptitude for package management, Fedora uses Yum. Centos 6 uses a specific version of the kernel, while version 7 uses another. You get one set of packages with Debian, another with Ubuntu. That&#8217;s the power of specific communities: how frequently things are updated, how well they&#8217;re maintained, and what you get out-of-box. A docker container jails a process to only see a specific part of the filesystem; specifically, the container&#8217;s file system. Using a distribution ensures that the required libraries and support binaries are there, in place, where they should be. But major distributions aren&#8217;t designed to run specific applications; their general-purposes servers that are designed to run a variety of apps and processes. If you want to run a single process there&#8217;s a lot that comes with an OS you don&#8217;t need.</p>

<p>There&#8217;s a re-emergence of lightweight linux distributions in the docker world first popularized with embedded systems. You&#8217;re probably familiar with <a href="https://registry.hub.docker.com/_/busybox/">busybox</a> useful for running one-off bash commands. Because of busybox&#8217;s embedded roots, it&#8217;s not quite intended for packages. <a href="https://www.alpinelinux.org">Alpine Linux</a> is another alternative which features its own <a href="https://registry.hub.docker.com/_/alpine/">official registry</a>. It&#8217;s still very small, based on busybox, and has its own package system. I tried getting gitlab&#8217;s ci-runner working with alpine, but unfortunately some of the ruby gems used by ci-runner require GNU packages which aren&#8217;t available, and I didn&#8217;t want to compile them manually. In terms of time/benefit, I can live with 400mb and move on to something else. For most things you can probably do a lot with Alpine and keep your containers really small: great for doing continuous deploys to a bunch of servers.</p>

<p>The bottom line is know what you need. If you want a minimal container, build up, rather than slim down. You usually need the runtime for your application (if any), your app, and supporting dependencies. Know those dependencies, and avoid cruft when you can.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/03/book-review-go-programming-blueprints-and-the-beauty-of-a-language/">Book Review: Go Programming Blueprints, and the beauty of a language.</a></h1>
        <span class="post-date">Mar 20 2015</span>
        <p>Just over two years ago my wife and I [traveled around Asia for several months)[thegreatbigadventure.tumblr.com]. I didnâ€™t do any programming while I was gone <a href="http://blog.michaelhamrah.com/2013/04/six-months-of-computer-science-without-computers/">but I did a great deal of reading</a>, gaining a new-found appreciation for programming and technology. I became deeply interested in Scala and Go for their respective approachs to statically typed languages. Scala for its functional programming aspects and Go for its refreshing and intentionally succinct approach to interfaces, types and its anti-inheritance. The criticism I most often here with Scala; thatâ€™s it too open, too free-for-fall in its paradigms is in stark contrast to the main criticisms I hear of Go: itâ€™s too limiting, too constrained.</p>

<p>Since returning a majority of my time is focused on Scala, yet I still keep a hand in the Go cookie jar. Both languages are incredibly productive, and I appreciate FP the more I use it and understand it. Scalaâ€™s criticism is legitimate; it can be a chaotic language. However, my personal opinion is the language shouldnâ€™t constrain you: itâ€™s the discipline of the programmer to write code well, not the language. A bad programmer is going to destroy any language; a good programmer can make any code beautiful. More importantly, no language is magical. A language is a tool, and itâ€™s up to the programmer to use it effectively.</p>

<p>Learning a language is more than just knowing how to write a class or function. Learning a language is about composing these together effectively and using the ecosystem around the language. Scalaâ€™s benefit is the ecosystem around the JVM; idiomatic Scala is contentious debate, as you have the functional programmers on one side and the more lenient anti-javaists on the other (Martin Oderskyâ€™s talk <a href="https://www.youtube.com/watch?v=ecekSCX3B4Q">Scala: The Simple Parts</a> is a great overview of where Scala shines). Go, on the other hand, is truly effective when you embrace its opinions and leverage its ecosystem: understanding imports and go get, writing small, independent modules, reusing these modules, embracing interfaces, and understanding the power of goroutines.</p>

<p>Last summer I had the great pleasure of being a technical reviewer for Mat Ryerâ€™s <a href="http://bit.ly/GoBb">Go Programming Blueprints</a>. Iâ€™ve read a great deal of programming books in my career and appreciated Matâ€™s approach to showcasing the power and simplicity of Go. Itâ€™s not for beginners programmers, but if you have some experience, not even with Go, you can kick-start a working knowledge easily with Matâ€™s book. My favorite aspect is it explains how to write idiomatic Go to build applications. One example application composes discrete services and links them with bitlyâ€™s NSQ library, another uses a routing library on top of Goâ€™s httpRequest handler. The book isnâ€™t just isolated to web programs, thereâ€™s a section on writing CLI apps which link together with standard in and standard out. For those criticizing Goâ€™s terseness Matâ€™s book exemplifies what you can do with those terse systems: write scalable, composable apps that are also maintainable and readable. The books shows why so many exciting new tools are written in Go: you can do a lot with little, and they compile to statically linked, minimal binaries.</p>

<p>As you develop your craft of writing code, you develop certain opinions on the way code should work. When your language is inline with your opinions, or you develop opinions based on the language, you are effectively using that language. If you are learning a new language, like Go, but still applying your existing opinions on how to develop applications (say, by wishing the language had Generics), you struggle. Worse, you are attempting to shape a new language to the one you know, effectively programming in the old language. You should embrace what the language offers, and honor its design decisions. Matâ€™s book shows how to apply Goâ€™s design decisions effectively. The language itself will evolve and grow, but it will do it in a way that enhances and honors its design decisions. And if you still donâ€™t like it, or Scala, well thereâ€™s always Rust.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/03/deploying-docker-containers-on-coreos-with-the-fleet-api/">Deploying Docker Containers on CoreOS with the Fleet API</a></h1>
        <span class="post-date">Mar 17 2015</span>
        

<p>I&#8217;ve been spending a lot more time with CoreOS in search of a docker-filled utopian PaaS dreams. I haven&#8217;t found quite what I&#8217;m looking for, but with some bash scripting, a little http, good tools and a lotta love I&#8217;m coming close. There are no shortage of solutions to this problem, and honestly, nobody&#8217;s really figured this out yet in an easy, fluid, turn-key type of way. You&#8217;ve probably read about CoreOS, Mesos, Marathon, Kubernetes&#8230; maybe even dug into Deis, Flynn, Shipyard. You&#8217;ve spun up a cluster, and are like&#8230; This is great, now what.</p>

<p>What I want is to go from an app on my laptop to running in a production environment with minimal fuss. I don&#8217;t want to re-invent the wheel; there are too many people solving this problem in a similar way. I like CoreOS because it provides a bare-bones docker runtime with a solid set of low-level tools. Plus, a lot of people I&#8217;m close with have been using it, so the cross-pollination of ideas helps overcome some hurdles.</p>

<p>One of these hurdles is how you launch containers on a cluster. I really like <a href="https://github.com/mesosphere/marathon">Marathon&#8217;s</a> http api for Mesos, but I also like the simplicity of CoreOS as a platform. CoreOS&#8217;s distributed init system is <a href="https://github.com/coreos/fleet">Fleet</a>, which leverages systemd for running a process on a CoreOS node (it doesn&#8217;t have to be a container). It has some nice features, but having to constantly write similar systemd files and run fleetctl to manage containers is somewhat annoying.</p>

<p>Turns out, <a href="https://github.com/coreos/fleet/blob/master/Documentation/api-v1.md">Fleet has an http API</a>. It&#8217;s not quite as nice as Marathon&#8217;s; you can&#8217;t easily scale to N number of instances, but it does come close. There are a few examples of using the API to launch containers, but I wanted a more end-to-end solution that eliminated boilerplate.</p>

<h2 id="activate-the-fleet-api:f1075c253a77011bd480830af8403bf8">Activate the Fleet API</h2>

<p>The Fleet API isn&#8217;t enabled out-of-the-box. That makes sense as the API is currently unsecured, so you shouldn&#8217;t enable it unless you have the proper VPC set up. <a href="https://coreos.com/docs/launching-containers/config/fleet-deployment-and-configuration/">CoreOS has good documentation on getting the API running</a>. For a quick start you can drop the following yaml snippet into your cloudconfig&#8217;s units section:</p>

<pre class="syntax yaml">- name: fleet.socket
  drop-ins:
    - name: 30-ListenStream.conf
      content: |
        [Socket]
        ListenStream=8080
        Service=fleet.service
        [Install]
        WantedBy=sockets.target
</pre>

<h2 id="exploring-the-api:f1075c253a77011bd480830af8403bf8">Exploring the API</h2>

<p>With the API enabled, it&#8217;s time to get to work. The <a href="https://github.com/coreos/fleet/blob/master/Documentation/api-v1.md">API has some simple documentation</a> but offers enough to get started. I personally like the minimal approach, although I wish it was more feature-rich (it is v1, and better than nothing).</p>

<p>You can do a lot with curl, bash and jq. First, let&#8217;s see what&#8217;s running. All these examples assume you have a FLEET_ENDPOINT environment variable set with the host and port:</p>

<p>On a side note, environment variables are key to reuse the same functionality across environments. In my opinion, they aren&#8217;t used nearly enough. Check out the <a href="http://12factor.net/config">twelve-factor app&#8217;s config section</a> to understand the importance of environment variables.</p>

<pre class="syntax bash">curl -s $FLEET_ENDPOINT/fleet/v1/units | jq '.units[] | { name: .name, currentState: .currentState}'
</pre>

<p>Sure, you can get the same data by running <code>fleetctl list-units</code>, but the http command doesn&#8217;t involve ssh, which can be a plus if you have a protected network, are are running from an application or CI server.</p>

<h2 id="creating-containers:f1075c253a77011bd480830af8403bf8">Creating Containers</h2>

<p>Instead of crafting a fleet template and running <code>fleetctl start sometemplate</code> , we want to launch new units via http. This involves PUTting a resource to the /units/ endpoint under the name of your unit (it&#8217;s actually /fleet/v1/units, it took me forever to find the path prefix). The Fleet API will build a corresponding systemd unit from the json payload, and the content closely corresponds to what you can do with <a href="https://coreos.com/docs/launching-containers/launching/fleet-unit-files/">a fleet unit file</a>.</p>

<p>The schema takes in a <code>desiredState</code> and an array of <code>options</code> which specify the <code>section</code>, <code>name</code>, and <code>value</code> for each line. Most Fleet templates follow a similar pattern as exemplified with <a href="https://coreos.com/docs/launching-containers/launching/launching-containers-fleet/">the launching containers with Fleet guide</a>:</p>

<ol>
<li>Cleanup potentially running containers</li>
<li>Pull the container</li>
<li>Run the container</li>
<li>Define X-Fleet parameters, like conflicts.</li>
</ol>

<p>Again we&#8217;ll use curl, but writing json on the command line is really annoying. So let&#8217;s create a <code>unit.json</code> for our payload defining the tasks for CoreOS&#8217;s apache container:</p>

<pre class="syntax json">{
  "desiredState": "launched",
  "options": [
    {
      "section": "Service",
      "name": "ExecStartPre",
      "value": "-/usr/bin/docker kill %p-i%"
    },
    {
      "section": "Service",
      "name": "ExecStartPre",
      "value": "-/usr/bin/docker rm %p-%i"
    },
    {
      "section": "Service",
      "name": "ExecStartPre",
      "value": "/usr/bin/docker pull coreos/%p"
    },
    {
      "section": "Service",
      "name": "ExecStart",
      "value": "/usr/bin/docker run --rm --name %pi-%i -p 80 coreos/%p /usr/sbin/apache2ctl -D FOREGROUND"
    },
    {
      "section": "Service",
      "name": "ExecStop",
      "value": "/usr/bin/docker stop %p-%i"
    },
    {
      "section": "X-Fleet",
      "name": "Conflicts",
      "value": "%p@*.service"
    }
  ]
}
</pre>

<p>There&#8217;s a couple of things of note in this snippet:</p>

<ul>
<li>We&#8217;re adding a &#8220;-&#8221; in front of the docker kill and docker rm commands of the ExecStartPre tasks. This tells to Fleet to continue if there&#8217;s an error; these tasks are precautionary to remove an existing phantom container if it will conflict with the newly launched one.</li>
<li>We&#8217;re using Fleet&#8217;s systemd placeholders %p and %i to replace actual values in our template with values from the template name. This provides a level of agnosticism in our template; we can easily reuse this template to launch different containers by changing the name. Unfortunately this doesn&#8217;t quite work in our example because it&#8217;s apache specific, but if you were running a container with an entry point command specified, it would work fine. You&#8217;ll also want to manage containers under your own namespace, either in a private or public registry.</li>
</ul>

<p>We can launch this file with curl:</p>

<pre class="syntax bash">curl -d @unit.json -w "%{http_code}" -H 'Content-Type: application/json' $FLEETCTL_ENDPOINT/fleet/v1/units/apache@1.service
</pre>

<p>If all goes well you&#8217;ll get back a <code>201 Created</code> response. Try running the <code>list units</code> curl command to see your container task.</p>

<p>We can run <code>fleetctl cat apache@1</code> to view the generated systemd unit:</p>

<pre class="syntax bash">[Service]
ExecStartPre=-/usr/bin/docker kill %p-%I
ExecStartPre=-/usr/bin/docker rm %p-%i
ExecStartPre=/usr/bin/docker pull coreos/%p
ExecStart=/usr/bin/docker run --rm --name %pi-%i -p 80 coreos/%p /usr/sbin/apache2ctl -D FOREGROUND
ExecStop=/usr/bin/docker stop %p-%i

[X-Fleet]
Conflicts=%p@*.service
</pre>

<p>Want to launch a second task? Just post again, but change the instance number from 1 to 2:</p>

<pre class="syntax bash">curl -d @unit.json -w "%{http_code}" -H 'Content-Type: application/json' $FLEETCTL_ENDPOINT/fleet/v1/units/apache@2.service
</pre>

<p>When you&#8217;re done with your container, you can simple issue a delete command to tear it down:</p>

<pre class="syntax bash">curl -X DELETE -w "%{http_code}" $FLEET_ENDPOINT/fleet/v1/units/apache@1.service
</pre>

<h2 id="deploying-new-versions:f1075c253a77011bd480830af8403bf8">Deploying New Versions</h2>

<p>Launching individual containers is great, but for continuous delivery, you need deploy new versions with no downtime. The example above used systemd&#8217;s placeholders for providing the name of the container, but left the apache commands in place. Let&#8217;s use another CoreOS example container from the <a href="https://coreos.com/blog/zero-downtime-frontend-deploys-vulcand/">zero downtime frontend deploys</a> blog post. This <code>coreos/example</code> container uses an entrypoint and tagged docker versions to go from a v1 to a v2 version of the app. Instead of creating multiple, similar, fleet unit files like that blog post, can we make an agnostic http call that works across versions? Yes we can.</p>

<p>Let&#8217;s conceptually figure out how this would work. We don&#8217;t want to change the json payload across versions, so the body must be static. We could use some form of templating or find-and-replace, but let&#8217;s try and avoid that complexity for now. Can we make due with the options provided us? We know that the %p parameter lets us pass in the template name to our body. So if we can specify the name and version of the container we want to launch in the name of the unit file we PUT, we&#8217;re good to go.</p>

<p>So we want to:</p>

<pre class="syntax bash">curl -d @unit.json -w "%{http_code"} -H 'Content-Type: application/json' $FLEETCTL_ENDPOINT/fleet/v1/units/example:1.0.0@1.service
</pre>

<p>I tried this with the above snippet, but replaced the pull and run commands above with the following:</p>

<pre class="syntax json">{
      "section": "Service",
      "name": "ExecStart",
      "value": "/usr/bin/docker run --rm --name %p-%i -p 80 coreos/%p"
    },
    {
      "section": "Service",
      "name": "ExecStop",
      "value": "/usr/bin/docker stop %p-%i"
    },
</pre>

<p>Unfortunately, this didn&#8217;t work because the colon, :, in example:1.0.0 make the name invalid for a container. I could forego the name, but then I wouldn&#8217;t be able to easily stop, kill or rm the container. So we need to massage the %p parameter a little bit. Luckily, bash to the rescue.</p>

<p>Unfortunately, systemd is a little wonky when it comes to scripting in a unit file. It&#8217;s relatively hard to create and access environment variables, you need fully-qualified paths, and multiple lines for arbitrary scripts are discouraged. After googling how exactly to do bash scripting in a systemd file, or why an environment variable wasn&#8217;t being set, I began to understand the frustration in the community on popular distros switching to systemd. But we can still make do with what we have by launching a <code>/bin/bash</code> command instead of the vanilla <code>/usr/bin/docker</code>:</p>

<pre class="syntax json">{
  "desiredState": "launched",
  "options": [
    {
      "section": "Service",
      "name": "ExecStartPre",
      "value": "-/bin/bash -c \"APP=`/bin/echo %p | sed 's/:/-/'`; /usr/bin/docker kill $APP-%i\""
    },
    {
      "section": "Service",
      "name": "ExecStartPre",
      "value": "-/bin/bash -c \"APP=`/bin/echo %p | sed 's/:/-/'`; /usr/bin/docker rm $APP-%i\""
    },
    {
      "section": "Service",
      "name": "ExecStartPre",
      "value": "/usr/bin/docker pull coreos/%p"
    },
    {
      "section": "Service",
      "name": "ExecStart",
      "value": "/bin/bash -c \"APP=`/bin/echo %p | sed 's/:/-/'`; /usr/bin/docker run --name $APP-%i -h $APP-%i -p 80 --rm coreos/%p\""
    },
    {
      "section": "Service",
      "name": "ExecStop",
      "value": "/bin/bash -c \"APP=`/bin/echo %p | sed 's/:/-/'`; /usr/bin/docker stop $APP-%i"
    },
    {
      "section": "X-Fleet",
      "name": "Conflicts",
      "value": "%p@*.service"
    }
  ]
}
</pre>

<p>and we can submit with:</p>

<pre class="syntax bash">curl -X PUT -d @unit.json -H 'Content-Type: application/json'  $FLEET_ENDPOINT/fleet/v1/units/example:1.0.0@1.service
</pre>

<p>More importantly, we can easily launch multiple containers of version two simultaneously:</p>

<pre class="syntax bash">curl -X PUT -d @unit.json -H 'Content-Type: application/json'  $FLEET_ENDPOINT/fleet/v1/units/example:2.0.0@1.service
curl -X PUT -d @unit.json -H 'Content-Type: application/json'  $FLEET_ENDPOINT/fleet/v1/units/example:2.0.0@2.service
</pre>

<p>and then destroy version one:</p>

<pre class="syntax bash">curl -X DELETE -w "%{http_code}" $FLEET_ENDPOINT/fleet/v1/units/example:1.0.0@1.service
</pre>

<h2 id="more-jq-and-bash-fun:f1075c253a77011bd480830af8403bf8">More jq and bash fun</h2>

<p>Let&#8217;s say you do start multiple containers, and you want to cycle them out and delete them. In our above example, we&#8217;ve started two containers. How will we easily go from v2 to v3, and remove the v3 nodes? The marathon API has a simple &#8220;scale&#8221; button which does just that. Can we do the same for CoreOS? Yes we can.</p>

<p>Conceptually, let&#8217;s think about what we want. We want to select all containers running a specific version, grab the full unit file name, and then curl a DELETE operation to that endpoint. We can use the Fleet API to get our information, jq to parse the response, and the bash pipe operator with xargs to call our curl command.</p>

<p>Stringing this together like so:</p>

<pre class="syntax bash">curl -s $FLEET_ENDPOINT/fleet/v1/units | jq '.units[] | .name | select(startswith("example:1.0.0"))' | xargs -t -I{} curl -s -X DELETE $FLEET_ENDPOINT/fleet/v1/units/{}
</pre>

<p>jq provides some very powerful json processing. We are pulling out the name field, and only selecting elements which start with our specific app and version, and then piping that to xargs. The -I{} flag for xargs is a substitution trick I learned. This allows you to do string placements rather than pass the field as an argument.</p>

<h2 id="conclusion:f1075c253a77011bd480830af8403bf8">Conclusion</h2>

<p>I can pretty much guarantee no matter what you pick to run your Docker PaaS, it won&#8217;t do exactly what you want. I can also guarantee that there will be a lot to learn: new apis, new commands, new tools. It&#8217;s going to feel like pushing a round peg in a square hole. But that&#8217;s okay; part of the experience is formulating opinions on how you want things to work. It&#8217;s a blend of learning the patterns and practices of a tool versus configuring it to work the way you want. Always remember a few things:</p>

<ul>
<li>Keep It Simple</li>
<li>Think about how it should work conceptually</li>
<li>You can do a lot with command line.</li>
</ul>

<p>With an API-enabled CoreOS cluster, you can easily plug deployment of containers to whatever build flow you use: your laptop, a github web hook, jenkins, or whatever flow you wish. Because all the above commands are bash, you can replace any part with a bash variable and execute appropriately. This makes parameterizing these commands into functions easy.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/01/adding-http-server-side-events-to-akka-streams/">Adding Http Server-Side Events to Akka-Streams</a></h1>
        <span class="post-date">Jan 18 2015</span>
        

<p>In my last blog post we pushed messages from RabbitMq to the console using Akka-Streams. We used the <a href="https://github.com/ScalaConsultants/reactive-rabbit">reactive-rabbit</a> library to create an Akka-Streams <code>Source</code> for our <em>streams-playground</em> queue and mapped the stream to a <code>println</code> statement before dropping it into an empty <code>Sink</code>. All Akka-Streams need both a <code>Source</code> and <code>Sink</code> to be runnable; we created a complete stream blueprint to be run later.</p>

<p>Printing to the console is somewhat boring, so let&#8217;s take it up a notch. The excellent <a href="spray.io">Spray Web Service</a> library is being merged into Akka as <a href="http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0-M2/scala/http/index.html">Akka-Http</a>. It&#8217;s essentially Spray built with Akka-Streams in mind. The routing dsl, immutable request/response model, and high-performance http server are all there; think of it as Spray vNext. Check out Mathias Doenitz&#8217;s <a href="http://spray.io/scaladays2014/#/">excellent slide deck on kaka-http from Scala days</a> to learn more on this evolution of Spray; it also highlights the back-pressure functionality Akka-Streams will give you for Http.</p>

<p>Everyone&#8217;s familiar with the Request/Response model of Http, but to show the power of Akka-Streams we&#8217;ll add Heiko Seeberger&#8217;s <a href="https://github.com/hseeberger/akka-sse">Akka-SSE</a> library which brings Server-Side Events to Akka-Http. <a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">Server-Side Events</a> are a more efficient form of long-polling that&#8217;s a lighter protocol to the bi-directional WebSocket API. It allows the client to easily register a handler which the server can then push events to. Akka-SSE adds an SSE-enabled completion marshaller to Akka-Http so your response can be SSE-aware. Instead of printing messages to the console, we&#8217;ll push those messages to the browser with SSE. This shows one of my favorite features of stream-based programming: we simply connect the specific pipes to create more complex flows, without worrying about the how; the framework handles that for us.</p>

<h2 id="changing-the-original-example:a9237168f3920272915cff712cbdae5e">Changing the Original Example</h2>

<p>If you&#8217;re interested in the code, simply <a href="https://github.com/mhamrah/streams-playground">clone the original repo</a> with <code>git clone https://github.com/mhamrah/streams-playground.git</code> and then <code>git checkout adding-sse</code> to get to this step in the repo.</p>

<p>To modify the original example we&#8217;re going to remove the <code>println</code> and <code>Sink</code> calls from <code>RabbitMqConsumer</code> so we can plug in our enhanced <code>Source</code> to the Akka-Http sink.</p>

<pre class="scala">def consume() = {
    Source(connection.consume("streams-playground"))
      .map(_.message.body.utf8String)
  }
</pre>

<p>This is now a partial flow: we build up the original RabbitMq <code>Source</code> with our map function to get the message body. Now the &#8220;other end&#8221; of the stream needs to be connected, which we defer until later. This is the essence of stream composition. There are multiple ways we can cut this up: our <code>map</code> call could be the only thing in this function, with our <code>RabbitMq</code> source defined elsewhere.</p>

<h2 id="adding-akka-http:a9237168f3920272915cff712cbdae5e">Adding Akka-Http</h2>

<p>If you&#8217;re familiar with Spray, Akka-Http won&#8217;t look that much different. We want to create an <code>Actor</code> for our http service. There are just a few different traits we extend our original Actor from, and a different way plug our routing functions into the Akka-Streams pipeline.</p>

<pre class="scala">class HttpService
  extends Actor
  with Directives
  with ImplicitFlowMaterializer
  with SseMarshalling {
  // implementation
  // ...
}
</pre>

<p><code>Directives</code> gives us the routing dsl, similar to <a href="http://spray.io/documentation/1.2.2/spray-routing/">spray-routing</a> (the functions are pretty much the same). Because Akka-Http uses Akka-Streams, we need an implicit <code>FlowMaterializer</code> in scope to run the stream. <code>ImplicitFlowMaterializer</code> provides a default. Finally, the <code>SseMarshalling</code> trait from Heiko Seeberger&#8217;s library provides the SSE functionality we want for our app. <em>If you&#8217;re interested in a robust Akka-Streams sample, Heiko&#8217;s <a href="https://github.com/hseeberger/reactive-flows">Reactive-Flows</a> is worth checking out.</em></p>

<p>##Binding to Http</p>

<p>Within our actor body we&#8217;ll create our http stream by binding a routing function to an http port. This is a little different than Spray; there&#8217;s just some syntactical sugar so we can plug our routing function directly into the http pipeline:</p>

<pre class="scala">//need an ExecutionContext for Futures
    import context.dispatcher

    //There's no receive needed, this is implicit
    //by our routing dsl.
    override def receive: Receive = Actor.emptyBehavior

    //We bind to an interface and create a 
    //Flow with our routing function
    Http()(context.system)
      .bind(Config.interface, Config.port)
      .startHandlingWith(route)

    //Simple composition of basic routes
    private def route: Route = sse ~ assets

    //Defined later
    private def see: Route = ???
    private def assets: Route = ???
</pre>

<p>If we weren&#8217;t using the Routing DSL we&#8217;d need to explicitly handling HttpRequest messages in our receive partial function. But the <code>startHandlingWith</code> call will do this for us; like spray-routing it takes in a routing function, and will call the appropriate route handler. New http requests will be pumped into the route handler and completed with the completion function at the end of the route.</p>

<p>##Adding SSE</p>

<p>The last piece of the puzzle is adding a specific route for SSE. We need two pieces for SSE support: first, an implicit function which converts the type produced from our <code>Source</code> to an <code>Sse.Message</code>; in this case, we need to go from a <code>String</code> to an <code>Sse.Message</code>. Secondly we need a route where a client can subscribe to the stream of server-side events.</p>

<pre class="scala">//Convert a String (our RabbitMq output) to an SSE Message
 implicit def stringToSseMessage(event: String): Sse.Message = {
      Sse.Message(event, Some("published"))
    }

 //add a route for our sse endpoint.
 private def sse: Route = {
      path("messages") {
        get {
          complete {
            RabbitMqConsumer.consume
          }
        }
      }
    }
</pre>

<p>In order for SSE to work in the browser we need to produce a stream of SSE messages with a specific content-type: <code>Content-Type: text/event-stream</code>. That&#8217;s what Akka-SSE provides: the SSE Message case classes and serialization to <code>text/event-stream</code>. Our implicit function <code>stringToSseMessage</code> allows the Scala types to align so the &#8220;stream pipes&#8221; can be attached together. In our case, we produce a stream of <code>String</code>s, our RabbitMq message body. We need to produce a stream of <code>SSE.Messages</code> so we add a simple conversion function. When a new client connects, they&#8217;ll attach themselves to the consuming RabbitMq <code>Source</code>. Akka-Http lets you natively complete a route with a <code>Flow</code>; Akka-Sse simply completes that <code>Flow</code> with the proper Http response for SSE.</p>

<h2 id="trying-it-out:a9237168f3920272915cff712cbdae5e">Trying It Out</h2>

<p>Fire up SBT and run <code>~reStart</code>, ensuring you have RabbitMq running and set up a queue named <code>streams-playground</code> (<a href="https://github.com/mhamrah/streams-playground/blob/master/README.md">see the README</a>). In your console, try a simple <code>curl</code> command:</p>

<pre class="bash">$ curl http://localhost:8080/messages
</pre>

<p>The curl command won&#8217;t return. Start sending messages via the RabbitMq Admin console and you&#8217;ll see the SSE output in action:</p>

<pre class="bash">$ curl localhost:8080/messages
event:published
data:woot!

event:published
data:another message!
</pre>

<p>Close the curl command, and fire up your browser at <code>http://localhost:8080</code> you&#8217;ll see a simple web page (served from the <code>assets</code> route). Continue sending messages via RabbitMq, and those messages will be added to the dom. Most modern browsers natively support SSE with the <code>EventSource</code> object. The following gist creates an event listener on the <code>'published'</code> event, which is produced from our <code>implicit string =&gt; sse</code> function above:</p>

<p>There&#8217;s also handlers for opening the initial sse connection and any errors produced. You could also add more events; our simple conversion only goes from a <code>String</code> to one specific SSE of type <code>published</code>. You could map a set of case classes&#8211;preferably an algebraic data type&#8211;to a set of events for the client. Most modern browsers support <code>EventStream</code>; there&#8217;s no need a for an additional framework or library. The gist above includes a test I copied from the <a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">html5 rocks page on SSE</a>.</p>

<h2 id="a-naive-implementation:a9237168f3920272915cff712cbdae5e">A Naive Implementation</h2>

<p>If you open up multiple browsers to localhost, or <code>curl http://localhost:8080/messages</code> a few times, you&#8217;ll notice that a published message only goes to one client. This is because our initial RabbitMq <code>Source</code> only consumes one message from a queue, and passes that down the stream pipeline. That single message will only go to one of the connected clients; there&#8217;s no fanout or broadcasting. You can do that with either RabbitMq or Akka-Streams, try experimenting for yourself!</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/01/a-gentle-introduction-to-akka-streams/">A Gentle Introduction To Akka Streams</a></h1>
        <span class="post-date">Jan 13 2015</span>
        

<p>I&#8217;m happy to see stream-based programming emerge as a paradigm in many languages. Streams have been around for a while: take a look at the good &#8216;ol | operator in Unix. Streams offer an interesting conceptual model to processing pipelines that is very functional: you have an input, you produce an output. You string these little functions together to build bigger, more complex pipelines. Most of the time you can make these functions asynchronous and parallelize them over input data to maximize throughput and scale. With a Stream, handling data is almost hidden behind the scenes: it just <em>flows</em> through <em>functions</em>, producing a new output from some input. In the case of an Http server, the Request-Response model across all clients is a Stream-based process: You map a Request to a Response, passing it through various functions which act on an input. Forget about MVC, it&#8217;s all middleware. No need to set variables, iterate over collections, orchestrate function calls. Just concatenate stream-enabled functions together, and run your code. Streams offer a succinct programming model for a process. The fact it also scales is a nice bonus.</p>

<p>Stream based programming is possible in a variety of languages, and I encourage you to explore this space. There&#8217;s an excellent <a href="https://github.com/substack/stream-handbook">stream handbook for Node</a>, <a href="https://github.com/matz/streem">an exploratory stream language from Yukihiro &#8220;Matz&#8221; Matsumoto of Ruby fame</a>, <a href="https://spark.apache.org/streaming/">Spark Streaming</a> and of course <a href="http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0-M2/index.html">Akka-Streams</a> which joins the existing <a href="https://github.com/scalaz/scalaz-stream">scalaz-stream</a> library for Scala. Even Go&#8217;s <a href="http://golang.org/pkg/net/http/#HandleFunc">HttpHandler function</a> is Stream-esque: you can easily wrap one function around another, building up a flow, and manipulate the Response stream accordingly.</p>

<h2 id="why-akka-streams:9c0e63de68271e30d1a6e002245492be">Why Akka-Streams?</h2>

<p>Akka-Streams provide a higher-level abstraction over Akka&#8217;s existing actor model. The Actor model provides an excellent primitive for writing concurrent, scalable software, but it still is a primitive; it&#8217;s not hard to find a few critiques of the model. So is it possible to have your cake and eat it too? Can we abstract the functionality we want to achieve with Actors into a set of function calls? Can we treat Actor Messages as Inputs and Outputs to Functions, with type safety? Hello, Akka-Streams.</p>

<p>There&#8217;s an excellent <a href="http://www.typesafe.com/activator/template/akka-stream-scala">activator template for Akka-Streams</a> offering an in-depth tutorial on several aspects of Akka-Streams. For a more a gentler introduction, read on.</p>

<h2 id="the-recipe:9c0e63de68271e30d1a6e002245492be">The Recipe</h2>

<p>To cook up a reasonable dish, we are going to consume messages from <a href="https://www.rabbitmq.com">RabbitMq</a> with the <a href="https://github.com/ScalaConsultants/reactive-rabbit">reactive-rabbit</a> library and output them to the console. The code is on <a href="https://github.com/mhamrah/streams-playground">GitHub</a>. If you&#8217;d like to follow along, <code>git clone</code> and then <code>git checkout intro</code>; hopefully I&#8217;ll build up more functionality in later posts so the master branch may differ.</p>

<p>Let&#8217;s start with a code snippet:</p>

<pre class="lang:scala">object RabbitMqConsumer {
 def consume(implicit flowMaterializer: FlowMaterializer) = {
    Source(connection.consume("streams-playground"))
      .map(_.message.body.utf8String)
      .foreach(println(_))
  }
}
</pre>

<ul>
<li>We use a RabbitMq connection to consume messages off of a queue named <code>streams-playground</code>.</li>
<li>For each message, we pull out the message and decode the bytes as a UTF-8 string</li>
<li>We print it to the console</li>
</ul>

<h2 id="the-ingredients:9c0e63de68271e30d1a6e002245492be">The Ingredients</h2>

<ul>
<li>A <code>Source</code> is something which produces exactly one output. If you need something that generates data, you need a <code>Source</code>. Our source above is produced from the <code>connection.consume</code> function.</li>
<li>A <code>Sink</code> is something with exactly one input. A <code>Sink</code> is the final stage of a Stream process. The <code>.foreach</code> call is a Sink which writes the input (_) to the console via <code>println</code>.</li>
<li>A <code>Flow</code> is something with exactly one input and one output. It allows data to flow through a function: like calling <code>map</code> which also returns an element on a collection. The <code>map</code> call above is a <code>Flow</code>: it consumes a <code>Delivery</code> message and outputs a <code>String</code>.</li>
</ul>

<p>In order to actually run something using Akka-Streams you must have both a <code>Source</code> and <code>Sink</code> attached to the same pipeline. This allows you to create a <code>RunnableFlow</code> and begin processing the stream. Just as you can compose functions and classes, you can compose streams to build up richer functionality. It&#8217;s a powerful abstraction allowing you to build your processing logic independently of its execution. Think of stream libraries where you &#8220;plug in&#8221; parts of streams together and customize accordingly.</p>

<h2 id="a-simple-flow:9c0e63de68271e30d1a6e002245492be">A Simple Flow</h2>

<p>You&#8217;ll notice the above snippet requires an <code>implicit flowMaterializer: FlowMaterializer</code>. A <code>FlowMaterializer</code> is required to actually run a <code>Flow</code>. In the snippet above <code>foreach</code> acts as both a <code>Sink</code> and a <code>run()</code> call to run the flow. If you look at the Main.scala file you&#8217;ll see I start the stream easily in one call:</p>

<pre class="lang:scala">implicit val flowMaterializer = FlowMaterializer()
  RabbitMqConsumer.consume
</pre>

<p>Create a queue named <code>streams-playground</code> via the RabbitMq Admin UI and run the application. You can use publish messages in the RabbitMq Admin UI and they will appear in the console. Try some UTF-8 characters, like Ã¥ÃŸÃ§âˆ‚!</p>

<h2 id="a-variation:9c0e63de68271e30d1a6e002245492be">A Variation</h2>

<p>The original snippet is nice, but it does require the implicit FlowMaterializer to build and run the stream in <code>consume</code>. If you remove it, you&#8217;ll get a compile error. Is there a way to separate the definition of the stream with the running of the stream? Yes, by simply removing the <code>foreach</code> call. <code>foreach</code> is just syntactical sugar for a <code>map</code> with a <code>run()</code> call. By explicitly setting a <code>Sink</code> without a call to <code>run()</code> we can construct our stream blueprint producing a new object of type <code>RunnableFlow</code>. Intuitively, it&#8217;s a <code>Flow</code> which can be <code>run()</code>.</p>

<p>Here&#8217;s the variation:</p>

<pre class="lang:scala">def consume() = {
     Source(connection.consume("streams-playground"))
      .map(_.message.body.utf8String)
      .map(println(_))
      .to(Sink.ignore) //won't start consuming until run() is called!
  }
</pre>

<p>We got rid of our <code>flowMaterializer</code> implicit by terminating our Stream with a <code>to()</code> call and a simple Sink.ignore which discards messages. This stream will not be run when called. Instead we must call it explicitly in Main.scala:</p>

<pre class="lang:scala">implicit val flowMaterializer = FlowMaterializer()
  RabbitMqConsumer.consume().run()
</pre>

<p>We&#8217;ve separated out the entire pipeline into two stages: the build stage, via the <code>consume</code> call, and the run stage, with <code>run()</code>. Ideally you&#8217;d want to compose your stream processing as you wire up the app, with each component, like RabbitMqConsumer, providing part of the overall stream process.</p>

<h2 id="a-counter-example:9c0e63de68271e30d1a6e002245492be">A Counter Example</h2>

<p>As an alternative, explore the <a href="http://www.rabbitmq.com/tutorials/tutorial-one-java.html">rabbitmq tutorials</a> for Java examples. Here&#8217;s a snippet from the site:</p>

<pre class="lang:java">QueueingConsumer consumer = new QueueingConsumer(channel);
    channel.basicConsume(QUEUE_NAME, true, consumer);

    while (true) {
      QueueingConsumer.Delivery delivery = consumer.nextDelivery();
      String message = new String(delivery.getBody());
      System.out.println(" [x] Received '" + message + "'");
    }
</pre>

<p>This is typical of an imperative style. Our flow is controlled by the while loop, we have to explicitly manage variables, and there&#8217;s no flow control. We could separate out the body from the while loop, but we&#8217;d have a crazy function signature. Alternatively on the Akka side there&#8217;s the solid <a href="https://github.com/sstone/amqp-client">amqp-client library</a> which provides an Actor based model over RabbitMq:</p>

<pre class="lang:scala">// create an actor that will receive AMQP deliveries
  val listener = system.actorOf(Props(new Actor {
    def receive = {
      case Delivery(consumerTag, envelope, properties, body) => {
        println("got a message: " + new String(body))
        sender ! Ack(envelope.getDeliveryTag)
      }
    }
  }))

  // create a consumer that will route incoming AMQP messages to our listener
  // it starts with an empty list of queues to consume from
  val consumer = ConnectionOwner.createChildActor(conn, Consumer.props(listener, channelParams = None, autoack = false))
</pre>

<p>You get the concurrency primitives via configuration over the actor system, but we still enter imperative-programming land in the Actor&#8217;s <code>receive</code> blog (sure, this can be refactored to some degree). In general, if we can model our process as a set of streams, we achieve the same benefits we get with functional programming: clear composition on what is happening, not how it&#8217;s doing it.</p>

<p>Streams can be applied in a variety of contexts. I&#8217;m happy to see the amazing and powerful <a href="http://spray.io">spray.io</a> library for Restful web services will be merged into Akka as a stream enabled http toolkit. It&#8217;s also not hard to find out what&#8217;s been done with <a href="https://github.com/scalaz/scalaz-stream#projects-using-scalaz-stream">scalaz-streams</a> or the plethora of tooling already available in other languages.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="http://blog.michaelhamrah.com/2015/01/dont-sweat-choice-in-tech-be-opinionated/">Donâ€™t Sweat Choice in Tech: Be Opinionated</a></h1>
        <span class="post-date">Jan 12 2015</span>
        <p>Recently I jumped back into some front-end development. My focus is primarily on backend systems and APIs so I welcomed the opportunity to hack on a UI. I keep tabs on the front-end world and a new project is a good opportunity for a test-drive or to level-up on an existing toolkit. The caveat, however, is the dreaded <a href="http://techcrunch.com/2014/10/18/you-too-may-be-a-victim-of-developaralysis/">developaralysis</a>. We have so many choices that discerning the difference, picking the &#8220;right one&#8221;, and learning it becomes an overwhelming endeavor. Should I try out <a href="http://gulpjs.com">gulp</a>? What about test-driving <a href="http://facebook.github.io/react/">react</a>? Or should I go with the usual bootstrap/angular combo I&#8217;ve come to know well?</p>

<p>It&#8217;s hard to balance the cost of time in the present for the potential&#8211;and I emphasize potential&#8211;benefit of speed and simplicity later when choosing something new. Time is limited; do I need an exploration of browserify, amd, and umd when all I really need is a simple <code>script</code> tag? Browserify looks cool, but what&#8217;s the return on that investment? The flood of options occurs at every level of experience; it&#8217;s endearing to overhear a debate amongst new developers on whether to learn rails or node first. It&#8217;s definitely not helpful when <a href="http://mashable.com/2014/01/21/learn-programming-languages/">sites offer laundry lists of languages you should learn</a>. C# and Java, really? I&#8217;m surprised assembly wasn&#8217;t on the list. Judging the nuances of NoSQL options is just as entertaining.</p>

<p>My programming career, now inching the 15-year mark, has seen its fair share of languages and frameworks. Happily I no longer think about ASP.NET view state or the server-control lifecycle. These were instrumental at one time, and even though they are long gone, those experiences helped shape my current opinions on how I want to develop (or, in this particular case, not to develop) software. I didn&#8217;t realize I had a choice back then on how I develop: ASP.NET seemed a given. That horrible windows-on-web paradigm pushed me to an intense focus on MVC, now a staple of many web frameworks. In turn, with the advent of APIs and more complex, task-focused UX, I am keenly interested in stream-based programming emerging in <a href="http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0-M2/scala/stream-index.html">Scala</a> and <a href="https://github.com/substack/stream-handbook">Node</a>. What I&#8217;ve come to realize in the tumultuous world of programming, and with constantly needing to level-up, is that frameworks and languages are only part of the equation. The most important part is me, and you: the developer. Steve Ballmer got it right: <a href="http://vimeo.com/6668315">it&#8217;s about developers</a>. Languages and frameworks help us do things but our opinions on how we want to do them is what moves us forward. When a framework matches your opinions, getting stuff done is simple and intuitive. When you feel like your jumping through hoops it&#8217;s time to try something different.</p>

<p>My small foray back into the front-end world was met with the usual whirlwind of information. Not to mention the usual upgrade of tools, so any answers I find on google will be outdated:</p>

<blockquote class="twitter-tweet" lang="en">
  <p>
    &#8220;What&#8217;s bower?&#8221; &#8220;A package manager, install it with npm.&#8221; &#8220;What&#8217;s npm?&#8221; &#8220;A package manager, you can install it with brew&#8221; &#8220;What&#8217;s brew?&#8221; &#8230;
  </p>
  
  <p>
    â€” Stefan Baumgartner (@ddprrt) <a href="https://twitter.com/ddprrt/status/529909875347030016">November 5, 2014</a>
  </p>
</blockquote>

<p>I just want to throw together a web site. Grunt vs. Gulp? Wait, there&#8217;s this thing called <a href="https://github.com/broccolijs/broccoli">Broccoli</a>? Is there something different than <a href="http://getbootstrap.com">Bootstrap</a> that&#8217;s less bootstrappy? Are people still using <a href="http://html5boilerplate.com">h5bp</a>?</p>

<p>It seemed even the simple go-to of <a href="http://yeoman.io"><code>yo angular</code></a> was fraught with peril: what are all these questions I have to answer? A massive amount of files were generated. Yes, all important and I know all required for various things, but it&#8217;s information overload. Why is <code>unresolved</code> added to the body tag? What happens if I hack the meta-viewport settings? What is <code>build:js</code> doing? Should I put on the blinders and ignore? Maybe I should try the possible simplicity of <a href="http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/">just using npm</a>. I was in it: developaralysis.</p>

<p>Stop. Relax. Breathe. I already knew the simple answer to navigating the awesome amount of choice: opinion. Forget about existing, pre-conceived notions of software. You need to do something: how would you do it? Chances are someone&#8217;s had a similar idea and <a href="https://github.com/explore">wrote some software</a>. Don&#8217;t even know what you need? Then start with something that&#8217;s easy to learn. If it doesn&#8217;t work out, you&#8217;ll have formed an opinion on what you wanted to happen. This is learning by fire.</p>

<p>Opinions have given birth to some of the most widely used software in the world. <a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)#Early_concept">Yukihiro Matsumoto created Ruby from his dissatisfaction with other OOP languages</a>. <a href="http://www.aosabook.org/en/nginx.html">Nginx was spawned by dissatisfaction in threaded web-servers</a>. You may not be ready to write a new language, framework, or web server, but your opinions can still shape what you learn and where you invest your time.</p>

<p>Nobody asked me a decade ago how I wanted to write web software. If they did I doubt I would have come up with anything similar to ASP.NET webforms, if I could even have put together a semi-coherent answer. Yet I was a full-time ASP.NET webforms developer, and that&#8217;s how I was writing software. Eventually my teammates and I realized this way of programming was utter crap. We asked ourselves that simple question, which we should have asked a lot earlier: How do we want to do this?</p>

<p>At any level it&#8217;s important to develop opinions on how you want to achieve goals. Beginners may seem they have a difficult spot because there&#8217;s so little grounding to formulate opinions: any answer may appear &#8220;too simple&#8221;. But the spectrum is the same for experience developers as well. There&#8217;s always &#8220;something else&#8221; to know and factor in behind the curtain. You&#8217;re constantly peeling layers off of the onion.</p>

<p>Don&#8217;t sweat the plethora of choice which exist. Nothing is perfect, and stagnation is the worst option. Take a moment and develop an opinion on how you want to solve a particular problem. Poke holes in your solution. See if somebody else has a similar idea, or a similar experience. Try something out: don&#8217;t like how it happened or the result? Did you leverage the tool correctly? Okay, great, now you have the basis for something better. Develop your suite of go-to tooling. You can keep tabs on the eco-system, and cross-pollinate ideas across similar veins. Choice is a good thing: like a breadth-first search, letting you still run forward if you want.</p>

    </div>
  
</div>

<div class="pagination">
  
  <a class="pagination-item older" href="http://blog.michaelhamrah.com/page/2/">Older</a>
  

  
  <span class="pagination-item newer">Newer</span>
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-6576586-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>

